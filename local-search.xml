<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/2022/08/5cd9ec8eff25/"/>
    <url>/2022/08/5cd9ec8eff25/</url>
    
    <content type="html"><![CDATA[<h2 id="引言">1. 引言</h2><p>首先, 明确一个问题, 什么是<ahref="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree"><strong>红黑树</strong></a>?红黑树的历史可以追溯至1972年, 一个姓 Bayer 的人发明了一种特殊的 B-tree数据结构(可见 B-tree 先于红黑树). 这种树的特点是具有极好的平衡特性,并且任一从根节点到叶子节点的路径所包含的节点数都一致——计算机界的强迫症尤为严重.但是, 这种树并不是一种二叉搜索树. Bayer 称这种树为 "对称二叉B-tree".当然, 后来就发展成为 2-3-4树(什么是2-3-4树本文暂且按下不表). 继而1978年,L.J. Guibas 和 R. Sedgewick 在论文<ahref="https://ieeexplore.ieee.org/document/4567957"><em>A DichromaticFramework for Balanced Trees</em></a>中,基于前面说的对称二叉B-tree推演出了红黑树.至于为什么叫<font color='red'>红</font><strong>黑</strong>树,一说红黑是作者工作时彩色激光打印机能够打印的最好看的色彩,一说是红颜色和黑颜色的笔方便绘制红黑树.不论如何事物的发展总是基于所处的历史条件下的,上世纪七八十年代规模化的集成电路已经发展起来了,可以说硬件正在以摩尔定律所预测的那样指数式更新迭代,与此同时科学家们也必须找到高效管理数据的方法, 以充分利用硬件资源,从操作系统到应用软件, 从电路设计到指令系统,计算机系统的大厦根基不是一天建成的.</p><div class="note note-primary">            <p>本文仅从数据结构角度介绍红黑树, 并不涉及其具体应用.</p>          </div><h2 id="定义">2. 定义</h2><p>要知道, 红黑树是一种特殊的2-3-4树,所有的自平衡二叉树都可以从2-3-4树那里寻得身影,可以说后者是一种平衡树的范式了. 笔者先介绍红黑树所具有的性质,再说明其结构体定义.</p><p>红黑树是一中二叉搜索树, 那肯定具有一般搜索树的性质,除此之外还应具有的性质有:</p><ol type="1"><li>每一个节点都需着色, 红或黑;</li><li>根节点始终着黑色;</li><li>每一个空叶子节点都着黑色;</li><li>如果一个节点着红色, 则其两个孩子节点着黑色,也即相邻的两个节点不能同时着红色;</li><li>任意节点到其后代空叶子的简单路径上的黑色节点数目都一致.</li></ol><p>下面给出红黑树的结构体定义:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> key;<br>    node* parent;<br>    <span class="hljs-keyword">char</span> color; <br>    node* left;<br>    node* right;<br>&#125;;<br></code></pre></td></tr></table></figure><div class="note note-success">            <p>注意: 法无常法, 在于道可.</p>          </div><h2 id="操作">3. 操作</h2><p>一个含有 <span class="math inline">\(n\)</span> 个节点的红黑树,树高不超过 <span class="math inline">\(2*log(n+1)\)</span>.<em>证明略,有兴趣的读者可以查阅资料</em>.这也就是为什么红黑树是一种搜索性能较好的平衡树: 任何情况下, 搜索都可以在<span class="math inline">\(O(log\ n)\)</span> 时间内结束.</p><h3 id="旋转">3.1 旋转</h3><p>搜索是不会破环第 2 节中关于红黑树定义所描述的性质的,插入和删除则不然. 同平常的平衡树一样,在对红黑树上的节点进行操作之后原有性质被破环,需要进行树的旋转(rotation). 这里还有一个言外之意,旋转前后的树或者子树保有的性质一致. 下面举个小例子.</p><p><img src="\img\rbtree\rotation.png" style="zoom:50%;"/></p><center>图1. 旋转示意</center><p>如图1所示, 不论将树结构向左旋还是右旋, 其中序遍历的结果都为: <spanclass="math inline">\(a\mbox{-}b\mbox{-}c\mbox{-}d\mbox{-}e\)</span>.结合红黑树的定义, 我们可以给出左旋的代码.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">leftrotate</span><span class="hljs-params">(node *p)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (p-&gt;right == <span class="hljs-literal">nullptr</span>)        <span class="hljs-comment">// 左旋判断右子树是否为空</span><br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        node *y = p-&gt;right;         <span class="hljs-comment">// 记录右子树的根节点y</span><br>        <span class="hljs-keyword">if</span>(y-&gt;left != <span class="hljs-literal">nullptr</span>)&#123;     <span class="hljs-comment">// 判断右子树y的左孩子是否为空, 不为空则,</span><br>            p-&gt;right = y-&gt;left;     <span class="hljs-comment">// 将右子树y的左孩子挂在节点p的右子树上</span><br>            y-&gt;left-&gt;parent = p;<br>        &#125;<br>        <span class="hljs-keyword">else</span>                        <span class="hljs-comment">// 如果为空, 则</span><br>            p-&gt;right = <span class="hljs-literal">nullptr</span>;     <span class="hljs-comment">// 直接挂空节点</span><br><br>        <span class="hljs-keyword">if</span>(p-&gt;parent != <span class="hljs-literal">nullptr</span>)    <span class="hljs-comment">// 判断节点p是否为顶层的根节点, 否, 则</span><br>            y-&gt;parent = p-&gt;parent;<br>        <span class="hljs-keyword">if</span>(p-&gt;parent == <span class="hljs-literal">nullptr</span>)    <span class="hljs-comment">// 如果节点p是根节点, 则</span><br>            root = y;               <span class="hljs-comment">// p的右子树y就为左旋后的树根</span><br><br>        <span class="hljs-keyword">else</span>&#123;                       <span class="hljs-comment">// 节点p远离树根</span><br>            <span class="hljs-keyword">if</span>(p == p-&gt;parent-&gt;left)<br>                p-&gt;parent-&gt;left = y;<br>            <span class="hljs-keyword">else</span><br>                p-&gt;parent-&gt;right = y;<br>        &#125;<br><br>        y-&gt;left = p;                <span class="hljs-comment">// 父子节点角色互换</span><br>        p-&gt;parent = y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>右旋的代码不再复制粘贴了:).</p><h3 id="插入删除">3.2 插入&amp;删除</h3><p>前文已经说明, 红黑树属于搜索树,所以其插入操作与二叉排序树的搜索插入类似,关键点在于变色以及根据着色特点进行再平衡即旋转的操作.根据第二节中所述的红黑树所具有的性质,可以总结出在插入或者删除之后调整红黑树的策略.</p><h4 id="插入"><strong>插入</strong></h4><p>简便起见,笔者使用流程图与伪代码相结合的方式描述插入(删除)操作的着色和旋转.插入操作的伪代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">step0: node *t = node_to_insert;<br>step1: <span class="hljs-built_in">bst_insert</span>(t);<br>step2: <span class="hljs-keyword">if</span> t==root  then set t-&gt;color RED;<br>        set node *p = t-&gt;parent; set node *g = t-&gt;parent-&gt;parent;<br>step3: <span class="hljs-keyword">if</span> p-&gt;color == RED &amp;&amp; t != root then:<br>        step3<span class="hljs-number">.1</span>: <span class="hljs-keyword">if</span> t-&gt;uncle-&gt;color = RED then:<br>                p-&gt;color = BLACK; t-&gt;uncle-&gt;color = BLACK; g-&gt;color = RED;<br>                set t = g;<br>                <span class="hljs-keyword">goto</span> step2;<br>        step3<span class="hljs-number">.2</span>: <span class="hljs-keyword">if</span> t-&gt;uncle-&gt;color = BLACK then:<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: LL- g-&gt;left = p &amp;&amp; p-&gt;left = t ===&gt; p-&gt;color = BLACK; <br>                        g-&gt;color = RED; <span class="hljs-built_in">rightrotate</span>(g);<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: LR- g-&gt;left = p &amp;&amp; p-&gt;right = t ===&gt; t = p; <span class="hljs-built_in">leftrotate</span>(t); <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: RR- g-&gt;right = p &amp;&amp; p-&gt;right = t ===&gt; p-&gt;color = BLACK; <br>                        g-&gt;color = RED; <span class="hljs-built_in">leftrotate</span>(g);<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: RL- g-&gt;right = p &amp;&amp; p-&gt;left = t ===&gt; t = p; <span class="hljs-built_in">rightrotate</span>(t); <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p><img src="\img\rbtree\rb_flow.svg" /></p><center>图2. 红黑树插入操作流程图</center><h4 id="删除"><strong>删除</strong></h4><p>删除操作的伪代码如下: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp">step0: node *p = node_to_delete;<br>step1: <span class="hljs-built_in">bst_delete</span>(p);<br>step2: <span class="hljs-keyword">if</span> p-&gt;parent-&gt;left == p then s = p-&gt;parent-&gt;right;<br>        step2<span class="hljs-number">.1</span>: <span class="hljs-keyword">if</span> s-&gt;color == red then:<br>                    s-&gt;color = black; p-&gt;parent-&gt;color = red;<br>                    <span class="hljs-built_in">leftrotate</span>(p-&gt;parent);<br>                    s = p-&gt;parent-&gt;right;<br>        step2<span class="hljs-number">.2</span>: <span class="hljs-keyword">if</span> s-&gt;right-&gt;color == black &amp;&amp; s-&gt;left-&gt;color == black then:<br>                    s-&gt;color = red;<br>                    p = p-&gt;parent;<br>        step2<span class="hljs-number">.3</span>: <span class="hljs-keyword">else</span> <br>            step2<span class="hljs-number">.3</span>.a: <span class="hljs-keyword">if</span> s-&gt;right-&gt;color == black then:<br>                        s-&gt;left-&gt;color = black;<br>                        s-&gt;color = red;<br>                        <span class="hljs-built_in">rightrotate</span>(s);<br>                        s = p-&gt;parent-&gt;right;<br>            step2<span class="hljs-number">.3</span>.b: s-&gt;color = p-&gt;parent-&gt;color;<br>                        p-&gt;parent-&gt;color = black;<br>                        s-&gt;right-&gt;color = black;<br>                        <span class="hljs-built_in">leftrotate</span>(p-&gt;parent);<br>                        p = root;<br>        step2<span class="hljs-number">.4</span>: p-&gt;color = black; root-&gt;color = black;<br>                    <span class="hljs-keyword">if</span> p!=root &amp;&amp; p-&gt;color == black <span class="hljs-keyword">goto</span> step2;<br>step3: <span class="hljs-keyword">else</span> s = p-&gt;parent-&gt;left;<br>        step3<span class="hljs-number">.1</span>: <span class="hljs-keyword">if</span> s-&gt;color == red then:<br>                    s-&gt;color = black; p-&gt;parent-&gt;color = red;<br>                    <span class="hljs-built_in">rightrotate</span>(p-&gt;parent);<br>                    s = p-&gt;parent-&gt;left;<br>        step3<span class="hljs-number">.2</span>: <span class="hljs-keyword">if</span> s-&gt;left-&gt;color == black &amp;&amp; s-&gt;right-&gt;color == black then:<br>                    s-&gt;color = red;<br>                    p = p-&gt;parent;<br>        step3<span class="hljs-number">.3</span>: <span class="hljs-keyword">else</span> <br>            step3<span class="hljs-number">.3</span>.a: <span class="hljs-keyword">if</span> s-&gt;left-&gt;color == black then:<br>                        s-&gt;right-&gt;color = black;<br>                        s-&gt;color = red;<br>                        <span class="hljs-built_in">leftrotate</span>(s);<br>                        s = p-&gt;parent-&gt;right;<br>            step3<span class="hljs-number">.3</span>.b: s-&gt;color = p-&gt;parent-&gt;color;<br>                        p-&gt;parent-&gt;color = black;<br>                        s-&gt;left-&gt;color = black;<br>                        <span class="hljs-built_in">rightrotate</span>(p-&gt;parent);<br>                        p = root;<br>        step3<span class="hljs-number">.4</span>: p-&gt;color = black; root-&gt;color = black;<br>                    <span class="hljs-keyword">if</span> p!=root &amp;&amp; p-&gt;color == black <span class="hljs-keyword">goto</span> step2;<br></code></pre></td></tr></table></figure></p><img src="\img\rbtree\rb_flow_delete.svg" /><center>图3. 红黑树删除操作流程图</center><div class="note note-success">            <p>本文仅以流程图和伪代码形式介绍红黑树的插入删除再平衡，未以实际着色图示辅助说明，请读者谅解，未解处请自行查阅资料。</p><p>还请常读常新。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自平衡二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谢尔德指针</title>
    <link href="/2022/07/d7e9fc032ed0/"/>
    <url>/2022/07/d7e9fc032ed0/</url>
    
    <content type="html"><![CDATA[<h1 id="shared_ptr">shared_ptr</h1><h2 id="简介">1. 简介</h2><p>前面一篇<ahref="https://socod.github.io/2022/05/d9b2728991b4/">文章</a>已经介绍过智能指针<span class="math inline">\(\texttt{unique\_ptr}\)</span>, 本节介绍<span class="math inline">\(\texttt{shared\_ptr}\)</span>.</p><p><span class="math inline">\(\texttt{std::shared\_ptr}\)</span>通过一个指针, 持有一个共享对象的所有权. <spanclass="math inline">\(\texttt{C++}\)</span> 允许多个 <spanclass="math inline">\(\texttt{shared\_ptr}\)</span> 指向同一个对象.当出现如下情形时, <spanclass="math inline">\(\texttt{shared\_ptr}\)</span>指向的对象会被销毁且其占用的内存空间会被回收:</p><ol type="1"><li><p>最后一个占有对象的指针 <spanclass="math inline">\(\texttt{shared\_ptr}\)</span> 被销毁;</p></li><li><p>最后一个占有对象的指针 <spanclass="math inline">\(\texttt{shared\_ptr}\)</span> 通过重载运算<code>operator=</code> 赋值给其他指针, 或者调用函数<code>reset()</code>时.</p></li></ol><p>上面的对象销毁可以使用删除器表达式, 或者是在构造期间提供给 <spanclass="math inline">\(\texttt{shared\_ptr}\)</span>的一个自定义删除器.</p><p><span class="math inline">\(\texttt{shared\_ptr}\)</span>能够在存储指向一个对象的指针时, 共享另一个对象的所有权.这一特性可以用来在占有其所属对象时, 指向成员对象. 所存储的指针可以被函数<code>get()</code>、解引用以及比较运算符访问. 当引用计数为 0 时,被管理的指针会被传递给删除器.</p><p>与 <span class="math inline">\(\texttt{unique\_ptr}\)</span> 类似,<span class="math inline">\(\texttt{shared\_ptr}\)</span>也可以不占有任何对象, 这种情况下即为 <em>empty</em>. 若一个空 <spanclass="math inline">\(\texttt{shared\_ptr}\)</span>是通过别名构造器创建的, 那么它就可能拥有非空的存储指针.</p><p>在不附加同步的情况下, 多个线程能在 <spanclass="math inline">\(\texttt{shared\_ptr}\)</span>的不同实例上调用所有的成员函数, 包括拷贝构造函数和拷贝赋值函数,即使这些实例是副本, 且共享同一个对象的所有权. 如果多个线程的执行,访问同一个 <span class="math inline">\(\texttt{shared\_ptr}\)</span>的实例而不进行同步, 并且任一线程调用 <spanclass="math inline">\(\texttt{shared\_ptr}\)</span> 的非<code>const</code> 成员函数, 那么就会出现数据竞争; <spanclass="math inline">\(\texttt{shared\_ptr}\)</span>中原子函数的重载可以避免数据竞争的发生.</p><div class="note note-info">            <p>优雅使用 <span class="math inline">\(\texttt{shared\_ptr}\)</span>的注意事项:</p>          </div><p>另外一个 <span class="math inline">\(\texttt{shared\_ptr}\)</span>指针要想共享一个对象的所有权,只能通过拷贝构造或者拷贝赋值的方式将其值赋给这个 <spanclass="math inline">\(\texttt{shared\_ptr}\)</span> 指针. 换句话说,用另一个 <span class="math inline">\(\texttt{shared\_ptr}\)</span>所占有的原始指针创建新的 <spanclass="math inline">\(\texttt{shared\_ptr}\)</span>将会导致未定义行为.</p><p>当然, <span class="math inline">\(\texttt{std::shared\_ptr}\)</span>允许不完整类型 T. 但是, 来自原始指针的构造器<code>template&lt;class Y&gt; shared_ptr(Y*)</code> 与 成员函数<code>template&lt;class Y&gt; void reset(Y*)</code>只能被指向完整类型的指针调用, 应当注意的是, <spanclass="math inline">\(\texttt{std::shared\_ptr}\)</span>可以通过一个原始指针构造成不完整类型.</p><p><spanclass="math inline">\(\texttt{std::shared\_ptr&lt;T&gt;}\)</span> 中的 T可以是函数类型: 也就是说, 这种情况下, T 是一个函数指针,而不是简单的对象指针.这种情况可以用来保有一个动态库或者作为一个插件进行装载,只要任意函数被引用了:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-keyword">void</span>(*)())</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-title">void</span><span class="hljs-params">()</span>&gt; <span class="hljs-title">ee</span><span class="hljs-params">(fun, del)</span></span>;<br>    (*ee)();<br>&#125;<br></code></pre></td></tr></table></figure><p>在如下典型的实现方式中, <spanclass="math inline">\(\texttt{std::shared\_ptr}\)</span>只持有两个指针:</p><ul><li><p><code>get()</code> 返回的指针;</p></li><li><p>指向 <em>控制块</em> 的指针.</p></li></ul><p>所谓的控制块是一种动态分配的对象:</p><ul><li><p>要么是指向所属对象的指针, 要么是所属对象自身;</p></li><li><p>无关类型的删除器;</p></li><li><p>无关类型的分配器;</p></li><li><p>占有被管理对象的 <spanclass="math inline">\(\texttt{shared\_ptr}\)</span> 指针的数量;</p></li><li><p>引用被管理对象的 <spanclass="math inline">\(\texttt{weak\_ptr}\)</span> 指针的数量.</p></li></ul><p>当通过 <spanclass="math inline">\(\texttt{std::make\_shared}\)</span> 或者 <spanclass="math inline">\(\texttt{std::allocate\_shared}\)</span> 方式创建<span class="math inline">\(\texttt{shared\_ptr}\)</span> 对象时,控制块和被管理对象二者的内存空间都是一次分配的.被管理对象是在控制块的数据成员中原位构造.</p><p>如果 <span class="math inline">\(\texttt{shared\_ptr}\)</span>是通过某个构造函数进行构造的,那被管理的对象和控制块必须分别进行内存空间的分配.这种情况下,控制块存有一个指向被管理对象的指针.</p><p><span class="math inline">\(\texttt{shared\_ptr}\)</span>所持有的指针可以通过 <code>get()</code> 直接返回,而由控制块管理的指针或者对象则是引用计数为0时被释放的那个. 因此,二者并不一定等价.</p><p><span class="math inline">\(\texttt{shared\_ptr}\)</span>的析构函数将控制块的引用计数减一. 如果引用计数减为0,控制块将会调用被管理对象的析构函数. 但控制块直到 <spanclass="math inline">\(\texttt{std::weak\_ptr}\)</span> 的引用计数为零时,才会被释放自身.</p><p>在现存实现方式中, 如果有一个共享指针指向同一个控制块,那弱指针数会自增一.</p><p>同时, 为了满足线程安全的要求, 引用计数会等价地使用 <spanclass="math inline">\(\texttt{std::memory\_order\_relaxed}\)</span> 中的<span class="math inline">\(\texttt{std::atomic::fetch\_add}\)</span>自增; 如果自减, 则要求严格的顺序, 安全地销毁控制块.</p><h2 id="示例">2. 示例</h2><p>示例代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-built_in">Base</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot; Base::Base()\n&quot;</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">Base</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot; Base::~Base()\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Derived</span>:</span> <span class="hljs-keyword">public</span> Base<br>&#123;<br>    <span class="hljs-built_in">Derived</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot; Derived::Derived()\n&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">Derived</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot; Derived::~Derived()\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">thr</span><span class="hljs-params">(std::shared_ptr&lt;Base&gt; p)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br><br>    std::shared_ptr&lt;Base&gt; lp = p;<br><br>    &#123;<br>        <span class="hljs-keyword">static</span> std::mutex io_mutex;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(io_mutex)</span></span>;<br>        std::cout   &lt;&lt; <span class="hljs-string">&quot;local pointer in a thread:\n&quot;</span><br>                    &lt;&lt; <span class="hljs-string">&quot;  lp.get() = &quot;</span> &lt;&lt; lp.<span class="hljs-built_in">get</span>()<br>                    &lt;&lt; <span class="hljs-string">&quot;, lp.use_count() = &quot;</span> &lt;&lt; lp.<span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(std::shared_ptr&lt;Base&gt; p)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;==================================&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;call copy&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    std::shared_ptr&lt;Base&gt; lp = p;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;current p use_count = &quot;</span> &lt;&lt; p.<span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;exist copy&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;==================================&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::shared_ptr&lt;Base&gt; p = std::make_shared&lt;Base&gt;();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Created a shared Derived (as a pointer to Base)\n&quot;</span><br>              &lt;&lt; <span class="hljs-string">&quot;  p.get() = &quot;</span> &lt;&lt; p.<span class="hljs-built_in">get</span>()<br>              &lt;&lt; <span class="hljs-string">&quot;, p.use_count() = &quot;</span> &lt;&lt; p.<span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(thr, p)</span>, <span class="hljs-title">t2</span><span class="hljs-params">(thr, p)</span>, <span class="hljs-title">t3</span><span class="hljs-params">(thr, p)</span></span>;<br><br><br>    <span class="hljs-built_in">copy</span>(p);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;current p.use_count() = &quot;</span> &lt;&lt; p.<span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    p.<span class="hljs-built_in">reset</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Shared ownership between 3 threads and released\n&quot;</span><br>              &lt;&lt; <span class="hljs-string">&quot;ownership from main:\n&quot;</span><br>              &lt;&lt; <span class="hljs-string">&quot;  p.get() = &quot;</span> &lt;&lt; p.<span class="hljs-built_in">get</span>()<br>              &lt;&lt; <span class="hljs-string">&quot;, p.use_count() = &quot;</span> &lt;&lt; p.<span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    t1.<span class="hljs-built_in">join</span>(); t2.<span class="hljs-built_in">join</span>(); t3.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;All threads completed, the last one deleted Derived\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">Base::Base()<br>Created a shared Derived (as a pointer to Base)<br>  p.get() = 0x80003a040, p.use_count() = 1<br>==================================<br>call copy<br>current p use_count = 6<br>exist copy<br>==================================<br>current p.use_count() = 4<br><br>Shared ownership between 3 threads and released<br>ownership from main:<br>  p.get() = 0, p.use_count() = 0<br>local pointer in a thread:<br>  lp.get() = 0x80003a040, lp.use_count() = 6<br>local pointer in a thread:<br>  lp.get() = 0x80003a040, lp.use_count() = 4<br>local pointer in a thread:<br>  lp.get() = 0x80003a040, lp.use_count() = 2<br> Base::~Base()<br>All threads completed, the last one deleted Derived<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>智能指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合理论的判定</title>
    <link href="/2022/06/a6effd395506/"/>
    <url>/2022/06/a6effd395506/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">1. 简介</h1><p>之前我们一直讨论的是关于特定理论的判定过程, 比如命题逻辑, 等式逻辑,量化公式等. 但在实践中, 多数情况是几种理论的组合,所以要讨论关于组合理论的判定过程.我们主要介绍熟知的Nelson-Oppen组合方法.该方法假设我们对每种涉及的理论都有一个判定过程.Nelson-Oppen组合方法允许判定过程彼此通信,以确保组合理论可靠且完备的判定过程.</p><p>首先说明几个组合理论中的重要概念.</p><p>组合理论(<strong>theory combination</strong>):分别给出符合签名(signature) <spanclass="math inline">\(\Sigma_1,\Sigma_2\)</span>的两个理论 <spanclass="math inline">\(T_1,T_2\)</span>. 组合理论 <spanclass="math inline">\(T_1\oplus T_2\)</span> 是定义在公理集合 <spanclass="math inline">\(T_1 \cup T_2\)</span> 上的 <spanclass="math inline">\((\Sigma_1\cup\Sigma_2)\)</span>-理论.</p><p>组合理论问题(<strong>the theory combination problem</strong>): 令<span class="math inline">\(\varphi\)</span> 是定义在签名 <spanclass="math inline">\(\Sigma_1\cup\Sigma_2\)</span> 上的组合理论公式.组合理论问题是判定组合理论 <span class="math inline">\(T_1\oplusT_2\)</span> 的有效性. 等价地, 这类问题是判断下式是否成立: <spanclass="math display">\[T_1\oplus T_2 \models \varphi.\]</span> 尽管理论 <span class="math inline">\(T_1,T_2\)</span>它们自身是可判定的, 但是它们的组合理论未必是可判定的.在一些特定的限制下, 组合理论就会是可判定的. 其中很重要的一个限制是,所涉及的理论是凸理论(<strong>convex theory</strong>).</p><p>凸理论: <span class="math inline">\(\Sigma\)</span>-理论 <spanclass="math inline">\(T\)</span> 是凸理论, 如果对于 <spanclass="math inline">\(\Sigma\)</span>-公式 <spanclass="math inline">\(\varphi\)</span> 中的所有合取式公式都有 <spanclass="math display">\[\begin{aligned}&amp;(\varphi\Longrightarrow \bigvee_{i=1}^nx_i=y_i)\ is\ T-valid\ for\some\ finite\ n\gt1\Longrightarrow\\&amp;(\varphi\Longrightarrow x_i=y_i)\ is\ T-valid\ for\ some\i\in\{1,...,n\}\end{aligned}\]</span> 其中, <span class="math inline">\(x_i,y_i\)</span> 为变量.</p><p>换句话说, 在一个凸理论 <span class="math inline">\(T\)</span> 中,如果一个公式 <span class="math inline">\(T-\)</span>蕴含 等式的析取,那么它也分别 <spanclass="math inline">\(T-\)</span>蕴含这些等式中的至少一项.</p><p>一下用两个例子来说明凸理论和非凸理论.</p><ul><li><p>在实数集 <span class="math inline">\(\mathbb{R}\)</span>上的线性演算是凸的. 线性算术谓词的合取定义了一组值, 这些值可以为空,单例, 如 <span class="math display">\[  x\le 3\land x\ge 3\Longrightarrow x=3,  \]</span> 或无限大, 因此它意味着无限的析取. 在所有三种情况下,它都符合凸理论的定义.</p></li><li><p>在整数集 <span class="math inline">\(\mathbb{Z}\)</span>上的线性演算是非凸的. 比如说, 当如下式子成立时 <spanclass="math display">\[  x_1=1\land x_2=2\land 1\le x_3\land x_3\le2\Longrightarrow(x_3=x_1\lor x_3=x_2).  \]</span> 以下两个式子都不成立: <span class="math display">\[  \begin{align*}  x_1=1\land x_2=2\land 1\le x_3\land x_3\le2\Longrightarrow x_3=x_1.\\  x_1=1\land x_2=2\land 1\le x_3\land x_3\le2\Longrightarrow x_3=x_2.  \end{align*}  \]</span></p></li></ul><h1 id="nelson-oppen-组合过程">2. Nelson-Oppen 组合过程</h1><p>Nelson-Oppen组合过程为符合某些规定的理论提供了解决理论组合问题的方法.组合过程可以分为凸理论组合和非凸理论的组合.</p><h2 id="凸理论组合">2.1 凸理论组合</h2><p>Nelson-Oppen 约束(<strong>Nelson-Oppen restrictions</strong>).为了能够应用Nelson-Oppen过程, 理论 <spanclass="math inline">\(T_1,...,T_n\)</span> 需要满足如下约束:</p><ol type="1"><li><span class="math inline">\(T_1,...,T_n\)</span>是具有等式的无量词一阶理论.</li><li>每一个理论 <span class="math inline">\(T_1,...,T_n\)</span>都有自己的判定过程.</li><li>签名是不相交的, 也即, 对于所有的 <span class="math inline">\(1\lei\lt j\le n\)</span>, <span class="math inline">\(\Sigma_i\cap\Sigma_j=\emptyset\)</span>.</li><li><span class="math inline">\(T_1,...,T_n\)</span>是解释在无穷域上的理论, 例如, 定义在实数集 <spanclass="math inline">\(\mathbb{R}\)</span> 上的线性演算,有限长度的位向量理论就不符合要求.</li></ol><p>如下所示的算法1 是组合凸理论的Nelson-Oppen过程. 算法接收一个公式<span class="math inline">\(\varphi\)</span> 作为输入,该公式必须是文字的合取式. 通常来说,向一个凸理论中添加析取式子会导致其成为非凸理论.具有析取关系的凸理论的扩展可以由我们稍后将介绍的非凸理论的扩展来支持,或者也可以通过无量词理论章节中介绍的方法来提供支持,这是基于将理论的判定过程与SAT求解器组合在一起.</p><p><span class="math display">\[\begin{align*}&amp;\mathbf{Algorithm\;1:}\; \text{NELSON-OPPEN-FOR-CONVEX-THEORIES}\\\\&amp;\mathbf{Input:}\; \text{A convex formula }\varphi\;\text{that mixesconvex theories, with}\\&amp;\quad\quad\quad\quad\text{restrictions as specified in Nelson-Oppenrestrictions}\\&amp;\mathbf{Output:}\; \text{``Satisfiable&#39;&#39; if}\varphi\;\text{is satisfiable, and &#39;&#39;Unsatisfiable&#39;&#39;otherwise}\\\\&amp;\;1.\; \it{Purification:}\;\text{Purify }\varphi\;\text{into}F_1,...,F_n.\\&amp;\;2.\; \text{Apply the decision procedure for }T_i\;\text{to}F_i.\; \text{If there exists }i\;\text{such that}\\&amp;\quad\; F_i\;\text{is unsatisfiable in }T_i,\;\text{return&#39;&#39;Unsatisfiable&#39;&#39;.}\\&amp;\;3.\; \it{Equality\ propagation:}\;\text{If there exist}i,j\;\text{such that }F_i\;T_i\mbox{-}\text{implies an equality}\\&amp;\quad\; \text{between variables of }\varphi\;\text{that is not}T_j\mbox{-}\text{implied by }F_j,\; \text{add this equality to }\\&amp;\quad\; F_j\;\text{and go to step 2}.\\&amp;\;4.\; \text{Return &#39;&#39;Satisfiable&#39;&#39;}.\end{align*}\]</span></p><p>算法1 的第一步依赖于纯化(<strong>purification</strong>)的思想.纯化是公式的保持可满足性的一种转化, 此后每个原子都来自特定的理论.在这种情况下, 我们说所有原子都是纯净(<strong>pure</strong>)的.更具体地讲, 给定一个公式 <span class="math inline">\(\varphi\)</span>,纯化产生如下等价的可满足公式 <spanclass="math inline">\(\varphi&#39;\)</span>:</p><ol type="1"><li><p>令 <spanclass="math inline">\(\varphi&#39;=\varphi\)</span>.</p></li><li><p>对于 <span class="math inline">\(\varphi&#39;\)</span>中的每一个子表达式 <span class="math inline">\(\phi\)</span>:</p><ol type="a"><li><p>用新的辅助变量 <span class="math inline">\(a_{\phi}\)</span> 替换<span class="math inline">\(\phi\)</span></p></li><li><p>用 <span class="math inline">\(a_{\phi}=\phi\)</span> 对 <spanclass="math inline">\(\varphi&#39;\)</span> 进行约束.</p></li></ol></li></ol><p><strong>例子1</strong>, 给定一个混合了线性演算和未解释函数的公式<span class="math display">\[\varphi:=x_1\le f(x_1),\]</span> 纯化的结果为 <span class="math display">\[\varphi&#39;:=x_1\le a\land a=f(x_1).\]</span> 公式 <span class="math inline">\(\varphi&#39;\)</span>中的所有原子都是纯的: <span class="math inline">\(x_1\le a\)</span>是一个线性演算的式子, <span class="math inline">\(a=f(x_1)\)</span>属于具有未解释函数的等式理论.</p><p>纯化之后, 剩下一组纯表达式 <spanclass="math inline">\(F_1,...,F_n\)</span>:</p><ol type="1"><li>所有的 <span class="math inline">\(i\)</span>, <spanclass="math inline">\(F_i\)</span> 属于理论 <spanclass="math inline">\(T_i\)</span>, 且是 <spanclass="math inline">\(T_i\)</span>-文字的合取式.</li><li>允许共享变量, 比如说, 存在 <span class="math inline">\(i,j,1\le i\ltj\le n, var(F_i)\cap var(F_j)\ne\emptyset\)</span>.</li><li>当且仅当 <span class="math inline">\(\bigwedge_{i=1}^nF_i\)</span>在组合理论中是可满足的时候, 组合理论中的公式 <spanclass="math inline">\(\varphi\)</span> 是可满足的.</li></ol><p><strong>例子2</strong>, 给定如下混合线性演算和未解释函数的式子 <spanclass="math display">\[(f(x_1,0)\ge x_3)\land (f(x_2,0)\le x_3)\land\\(x_1\ge x_2)\land (x_2\ge x_1)\land\\(x_3-f(x_1,0)\ge 1),\]</span> 纯化之后得到公式 <span class="math display">\[\begin{aligned}&amp;(a_1\ge x_3)\land(a_2\le x_3)\land(x_1\ge x_2)\land (x_2\gex_1)\land (x_3-a_1\ge 1)\land\\&amp;(a_0=0)\land\\&amp;(a_1=f(x_1,a_0))\land\\&amp;(a_2=f(x_2,a_0)).\end{aligned}\tag{1}\]</span> 如下表所示, 我们可以得到基于上面公式的判定过程:</p><p>表1.</p><table><colgroup><col style="width: 61%" /><col style="width: 38%" /></colgroup><thead><tr class="header"><th style="text-align: left;"><spanclass="math inline">\(F_1(\mathbb{R}\ 上的线性演算)\)</span></th><th style="text-align: left;"><span class="math inline">\(F_2(\rmEUF)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><span class="math inline">\(a_1\gex_3\)</span><br /><span class="math inline">\(a_2\lex_3\)</span><br /><span class="math inline">\(x_1\gex_2\)</span><br /><span class="math inline">\(x_2\gex_1\)</span><br /><span class="math inline">\(x_3-a_1\ge1\)</span><br /><span class="math inline">\(a_0=0\)</span></td><td style="text-align: left;"><spanclass="math inline">\(a_1=f(x_1,a_0)\)</span><br /><spanclass="math inline">\(a_2=f(x_2,a_0)\)</span></td></tr><tr class="even"><td style="text-align: left;"><span class="math inline">\(\star\x_1=x_2\)</span><br /><span class="math inline">\(\ \a_1=a_2\)</span><br /><span class="math inline">\(\stara_1=x_3\)</span><br /><span class="math inline">\(\star\ \rmFALSE\)</span><br /></td><td style="text-align: left;"><spanclass="math inline">\(x_1=x_2\)</span><br /><spanclass="math inline">\(\star\ a_1=a_2\)</span></td></tr></tbody></table><p>表1 显示了将公式(1)分为了两个纯公式 <spanclass="math inline">\(F_1\)</span> 和 <spanclass="math inline">\(F_2\)</span>. 第一个公式是一个线性演算式子,第二个公式是一个具有未解释函数的等式理论公式(EUF). <spanclass="math inline">\(F_1\)</span> 和 <spanclass="math inline">\(F_2\)</span> 都不是独立矛盾的, 因此,我们继续执行算法步骤3. 通过对实数进行线性算术的判定过程, 我们从<spanclass="math inline">\(F_1\)</span> 推断出 <spanclass="math inline">\(x_1 = x_2\)</span>,并将这一事实传播到另一个理论(即, 我们添加此等式至 <spanclass="math inline">\(F_2\)</span>). 现在我们可以推导 <spanclass="math inline">\(T_2\)</span> 中的 <span class="math inline">\(a_1= a_2\)</span> , 并将该等式传播到 <spanclass="math inline">\(F_1\)</span>. 从这个等式中, 我们得出 <spanclass="math inline">\(T1\)</span> 中的 <span class="math inline">\(a_1 =x_3\)</span>, 这与 <span class="math inline">\(T_1\)</span>中的 <spanclass="math inline">\(x_3-a_1\ge 1\)</span> 矛盾. 所以原公式为假.</p><h2 id="非凸理论组合">2.2 非凸理论组合</h2><p>接下来讨论非凸理论的组合(或者凸理论和非凸理论的组合). 首先,考虑如下的例子,该例表明了在凸理论组合算法处理的公式中如果其中有理论不是凸的,可能导致算法失效: <span class="math display">\[(1\le x)\land (x\le 2)\land p(x)\land \neg p(1)\land \neg p(2),\tag{2}\]</span> 其中 <span class="math inline">\(x\in \mathbb{Z}\)</span>.上述表达式混合了整数的线性演算和未解释函数谓词. 正如前面所描述的,针对整数的线性演算不是凸的. 纯化之后的结果得到 <spanclass="math display">\[\begin{aligned}&amp;1\le x\land x\le 2\land p(x)\land \neg p(a_1)\land\negp(a_2)\land\\&amp;a_1=1\land\\&amp;a_2=2\end{aligned}\]</span> 下表展示了上面非凸理论公式谓词分为两个纯公式 <spanclass="math inline">\(F_1\)</span> 和 <spanclass="math inline">\(F_2\)</span>. 应当注意到 <spanclass="math inline">\(F_1\)</span> 和 <spanclass="math inline">\(F_2\)</span> 各自都是可满足的,但是在各自的理论中不能推出任何等式. 因此,尽管该凸理论原公式是不可满足的, 凸理论组合算法仍然返回的是"Satisfiable".</p><p>该判定过程中所存在的问题, 不仅仅要关注蕴含等式,还要注意蕴含等式的析取. 回想一下, 变量是有限的,因此存在相等性和相等性的析取关系, 这意味着计算这些含义是可行的.给定这样的析取关系, 将问题分解为与析取关系一样多的部分,然后以递归方式调用该过程. 以公式(2) 的例子来说, <spanclass="math inline">\(F_1\)</span> 能够蕴含 <spanclass="math inline">\(x=1\lor x=2\)</span>. 因此,我们可以把问题一分为二, 分别考虑 <spanclass="math inline">\(x=1\)</span> 和 <spanclass="math inline">\(x=2\)</span> 的情况. 算法2 在算法1中添加了一个步骤: 该步骤就是实现该分割的.</p><p><span class="math display">\[\begin{align*}&amp;\mathbf{Algorithm\;2:}\; \text{NELSON-OPPEN}\\\\&amp;\mathbf{Input:}\;\;\; \text{A formula }\varphi\;\text{that mixestheories, with restrictions as specified}\\&amp;\quad\quad\quad\quad\text{in Nelson-Oppen restrictions}\\&amp;\mathbf{Output:}\; \text{&#39;&#39;Satisfiable&#39;&#39; if}\varphi\;\text{is satisfiable, and &#39;&#39;Unsatisfiable&#39;&#39;otherwise}\\\\&amp;\;1.\; \it{Purification:}\;\text{Purify }\varphi\;\text{into}\varphi&#39;=F_1,...,F_n.\\&amp;\;2.\; \text{Apply the decision procedure for }T_i\;\text{to}F_i.\; \text{If there exists }i\;\text{such that}\\&amp;\quad\; F_i\;\text{is unsatisfiable},\;\text{return``Unsatisfiable&#39;&#39;.}\\&amp;\;3.\; \it{Equality\ propagation:}\;\text{If there exist}i,j\;\text{such that }F_i\;T_i\mbox{-}\text{implies an equality}\\&amp;\quad\; \text{between variables of }\varphi\;\text{that is not}T_j\mbox{-}\text{implied by }F_j,\; \text{add this equality to }\\&amp;\quad\; F_j\;\text{and go to step 2}.\\&amp;\;4.\; \it{Splitting:}\;\text{If there exists }i\;\text{suchthat}\\&amp;\quad\;\;  \bullet \quad\quad F_i\Longrightarrow(x_1=y_1\vee\cdots\vee x_k=y_k)\;\text{and}\\&amp;\quad\;\;  \bullet \quad\quad \forall j\in\{1,...,k\}.\;F_i\nRightarrow x_j=y_j,\\&amp;\quad\;\; \text{then apply NELSON-OPPEN recursively to}\\&amp;\hspace{50mm} \varphi&#39;\wedge x_1=y_1,...,\varphi&#39;\wedgex_k=y_k.\\&amp;\quad\;\; \text{If and of these subproblems is satisfiable, return&#39;&#39;Satisfiable&#39;&#39;. Otherwise,}\\&amp;\quad\;\; \text{return &#39;&#39;Unsatisfiable&#39;&#39;}.\\&amp;\;5.\; \text{Return &#39;&#39;Satisfiable&#39;&#39;}.\end{align*}\]</span></p><p><strong>例子3</strong>, 继续考虑公式(2.1). 算法2 从 <spanclass="math inline">\(F_1\)</span> 中推出 <spanclass="math inline">\(x=1\lor x=2\)</span>, 并将该问题分为两个子问题,如下面两个表所示.</p><p>表2. <span class="math inline">\(x=a_1\)</span> 的情况</p><table><colgroup><col style="width: 52%" /><col style="width: 47%" /></colgroup><thead><tr class="header"><th><span class="math inline">\(F_1(整数集上的线性运算)\)</span></th><th><span class="math inline">\(F_2(\rm EUF)\)</span></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(1\le x\)</span><br /><spanclass="math inline">\(x\le 2\)</span><br /><spanclass="math inline">\(a_1=1\)</span><br /><spanclass="math inline">\(a_2=2\)</span></td><td><span class="math inline">\(p(x)\)</span><br /><spanclass="math inline">\(\neg p(a_1)\)</span><br /><spanclass="math inline">\(\neg p(a_2)\)</span></td></tr><tr class="even"><td><span class="math inline">\(x=1\)</span><br /><spanclass="math inline">\(\star\ x=a_1\)</span></td><td><br /><span class="math inline">\(x=a_1\)</span><br /><spanclass="math inline">\(\rm FALSE\)</span></td></tr></tbody></table><p>表3. <span class="math inline">\(x=a_2\)</span> 的情况</p><table><colgroup><col style="width: 52%" /><col style="width: 47%" /></colgroup><thead><tr class="header"><th><span class="math inline">\(F_1(整数集上的线性运算)\)</span></th><th><span class="math inline">\(F_2(\rm EUF)\)</span></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(1\le x\)</span><br /><spanclass="math inline">\(x\le 2\)</span><br /><spanclass="math inline">\(a_1=1\)</span><br /><spanclass="math inline">\(a_2=2\)</span></td><td><span class="math inline">\(p(x)\)</span><br /><spanclass="math inline">\(\neg p(a_1)\)</span><br /><spanclass="math inline">\(\neg p(a_2)\)</span></td></tr><tr class="even"><td><span class="math inline">\(x=2\)</span><br /><spanclass="math inline">\(\star\ x=a_2\)</span></td><td><br /><span class="math inline">\(x=a_2\)</span><br /><spanclass="math inline">\(\rm FALSE\)</span></td></tr></tbody></table><p>由此, 因为两个子问题为假, 所以原问题不可满足.</p>]]></content>
    
    
    <categories>
      
      <category>判定过程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>组合理论</tag>
      
      <tag>Nelson-Oppen</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>量化公式</title>
    <link href="/2022/06/6d923e6ce0cf/"/>
    <url>/2022/06/6d923e6ce0cf/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">1.简介</h1><p>量化允许我们指定谓词的有效性范围, 换句话说,即谓词应包含的域(值的范围).用于指定量化的逻辑中使用的语法元素称为量词(<strong>quantifier</strong>).最常用的两个量词分别是全称量词 "<spanclass="math inline">\(\forall\)</span>"和存在量词 "<spanclass="math inline">\(\exists\)</span>". 这两个量词是可以相互转换的:<span class="math display">\[\forall x.\varphi \Longleftrightarrow \neg\exists x.\neg\varphi.\]</span> 一些量化声明的例子:</p><ul><li><p>对于任意整数 <span class="math inline">\(x\)</span>, 存在一个整数<span class="math inline">\(y\)</span> 小于 <spanclass="math inline">\(x\)</span>: <span class="math display">\[  \forall x\in \mathbb{Z}.\exists y\in \mathbb{Z}.y\lt x.  \]</span></p></li><li><p>存在一个整数 <span class="math inline">\(y\)</span>,对于任意一个整数 <span class="math inline">\(x\)</span>, <spanclass="math inline">\(x\)</span> 总是大于 <spanclass="math inline">\(y\)</span>: <span class="math display">\[  \exists y\in\mathbb{Z}.\forall x\in\mathbb{Z}.x\gt y.  \]</span></p></li><li><p>对于任意大于1的自然数 <span class="math inline">\(n\)</span>,存在一个质数 <span class="math inline">\(p\)</span>, 使得 <spanclass="math inline">\(n\lt p\lt 2n\)</span>: <spanclass="math display">\[  \forall n\in\mathbb{N}.\exists p\in\mathbb{N}.n\gt 1\Longrightarrow(isprime(p)\land n\lt p\lt 2n).  \]</span></p></li></ul><p>在以上三个示例中, 全称量词和存在量词之间存在量词交替. 实际上,我们在前面考虑的可满足性和有效性问题可以解释为具有非交替量词的公式的判定问题.当我们考虑命题公式 <span class="math display">\[x\lor y\]</span> 是否可满足时, 可以等价地考虑是否 <em>存在</em> 一组 <spanclass="math inline">\(x,y\)</span> 的赋值满足该公式. 相似地,当我们考虑对于 <span class="math inline">\(x,y\in \mathbb{N}\)</span><span class="math display">\[x\gt y\lor x\lt y\]</span> 是否成立, 可以等价地考虑对于 <em>任意</em> 自然数 <spanclass="math inline">\(x,y\)</span>, 该公式是否成立.</p><p>所以, 上面两个判定问题地等价形式分别是 <span class="math display">\[\exists x\in \mathbb{B}.\exists y\in\mathbb{B}.(x\lor y)\]</span> 和 <span class="math display">\[\forall x\in\mathbb{N}.\forall y\in\mathbb{N}.x\gt y\lor x\lt y.\]</span> 下面引入两个在量化公式中比较重要的两个概念.</p><p><strong>自由变量</strong>(<strong>free variable</strong>).在一个给定的公式中, 至少有一个变量不受任何量词约束,那么该变量称作自由变量.</p><p><strong>句子</strong>(<strong>sentence</strong>). 如果一个公式 <spanclass="math inline">\(\mathcal{Q}\)</span> 中的变量没有一个是自由变量,那么该公式就成为句子.</p><p>我们只考虑句子形式的公式, 也就是说只关注无自由变量公式的判定问题.应该注意到, 带有量词的任意一阶理论都是不可判定的.所以我们只讨论可判定的理论.</p><h2 id="量化布尔公式">1.1 量化布尔公式</h2><p>量化命题逻辑(<strong>quantified propositionallogic</strong>)是用量词增强的命题逻辑.量化命题逻辑中的句子被称为量化布尔公式(<strong>quantified Booleanformulas</strong>, QBF). 逻辑允许的句子集合由以下语法定义: <spanclass="math display">\[\begin{align*}formula&amp;:formula\land formula\ |\ \neg formula\ |\ (formula)\ \\&amp;\;|\;identifier\ |\ \exists identifier.formula\end{align*}\]</span> QBF 可用于规划问题的建模, 比如说国际象棋问题. 比如说,对于一个象棋玩家来说, 判断是否存在一个在 <spanclass="math inline">\(k\)</span> 步之内取胜的策略.给定棋盘状态并假设白棋先行, 不管黑棋的步数如何, 白棋能否以 <spanclass="math inline">\(k\)</span> 步率先吃掉黑棋的国王.这类问题可以用QBF进行建模, 因为这相当于问白棋是否 <em>存在</em>这样一种走法, 使得对于黑棋 <em>所有</em> 可能的走法, 白棋在 <spanclass="math inline">\(k\)</span> 步之内取胜. 应该知道 <spanclass="math inline">\(k\)</span> 须得为奇数. 这就是典型的规划问题.我们以 QBF 的形式对象棋问题进行建模.</p><table><colgroup><col style="width: 20%" /><col style="width: 80%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(\rm标识符\)</span></th><th><span class="math inline">\(\rm 意义\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(x_{\{m,n,i\}}\)</span></td><td>棋子 <span class="math inline">\(m\)</span> 第 <spanclass="math inline">\(i\)</span> 步骤在棋盘上所处的位置 <spanclass="math inline">\(n\)</span>, 其中 <span class="math inline">\(1\lem\le 4s, 0\le n\le s^2, 0\le i\le k\)</span>.</td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(I_0\)</span></td><td><span class="math inline">\(x_{\{m,n,0\}}\)</span> 变量上的子句集合,表示棋盘的初始状态.</td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(T^w_i\)</span></td><td><span class="math inline">\(x_{\{m,n,i\}}, x_{\{m,n,i+\}}\)</span>变量上的子句集合, 表示白棋在步骤 <span class="math inline">\(i\)</span>的有效移动.</td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(T^b_i\)</span></td><td><span class="math inline">\(x_{\{m,n,i\}}, x_{\{m,n,i+\}}\)</span>变量上的子句集合, 表示黑棋在步骤 <span class="math inline">\(i\)</span>的有效移动.</td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(G_k\)</span></td><td><span class="math inline">\(x_{\{m,n,k\}}\)</span> 变量上的子句集合,表示棋局的目标, 比如说, 在 <span class="math inline">\(k\)</span>步之内, 黑棋的国王被白棋吃掉.</td></tr></tbody></table><p>由此可以公式化该问题, 得到公式: <span class="math display">\[\begin{align*}&amp;\exists\{x_{\{m,n,0\}}\}\exists\{x_{\{m,n,1\}}\}\forall\{x_{\{m,n,2\}}\}\exists\{x_{\{m,n,3\}}\}...\forall\{x_{\{m,n,k-1\}}\}\exists\{x_{\{m,n,k\}}\}.\\&amp;I_0\land ((T^b_1\land T^b_3\land ...\land T^b_{k-2})\Longrightarrow (T^w_0\land T^w_2\land ...\land T^w_{k-1}\land G_k)).\end{align*}\]</span> 其实, 该公式并不能够很好的对问题进行描述.由于僵局出现的可能性: 可能存在这样一种情况, 黑方无法采取有效措施,导致平局. 在这种情况下上面的公式是有效的, 尽管它是不应该有效的.该问题的可能解决方案是通过适当地修改 <spanclass="math inline">\(T^w\)</span> 来禁止白棋进行导致这种状态的走法.</p><h2 id="量化析取线性演算">1.2 量化析取线性演算</h2><p>量化析取线性演算(<strong>quantified disjunctive lineararithmetic</strong>, QDLA)的文法定义如下: <span class="math display">\[\begin{aligned}formula&amp;:formula\land formula\ |\ \neg formula\ |\ (formula)\ \\&amp;\;|\;predicate\ |\ \forall identifier.formula\\predicate&amp;:\Sigma_ia_ix_i\lt c.\end{aligned}\]</span> 其中 <span class="math inline">\(c, a_i\)</span> 为常数, <spanclass="math inline">\(x_i\)</span>为实型变量. 比如说, 如下公式就是QDLA:<span class="math display">\[\forall x.\exists y.\exists z.((y+1\le x\hspace{1pc} \lor\hspace{1pc}z+1\le y )\hspace{1pc} \land\hspace{1pc} 2x+1\lt z).\]</span></p><h1 id="量词消除quantifier-elimination">2. 量词消除(<strong>QuantifierElimination</strong>)</h1><h2 id="前束范式prenex-normal-form">2.1 前束范式(<strong>prenex normalform</strong>)</h2><p>首先定义针对量化公式的范式.</p><p><strong>前束范式</strong>. 如果一个公式符合如下形式则称之为前束范式:<span class="math display">\[Q[n]V[n]...Q[1]V[1].\langle quantifier\mbox{-}free formula\rangle,\]</span> 其中, 对于所有的 <spanclass="math inline">\(i\in\{1,2,...,n\}, Q[i]\in\{\forall,\exists\}\)</span>, <span class="math inline">\(V[i]\)</span>是一个变量. 我们将公式左侧的量化字符串称为量化前缀,而将量化前缀右侧的无量词公式称为量化后缀.</p><p><strong>引理</strong>. 对于每一个量化公式 <spanclass="math inline">\(\mathcal{Q}\)</span>, 存在一个前束范式形式的公式<span class="math inline">\(\mathcal{Q}&#39;\)</span>, 当且仅当 <spanclass="math inline">\(\mathcal{Q}&#39;\)</span> 为真时 <spanclass="math inline">\(\mathcal{Q}\)</span> 为真.</p><p>对于量化公式的判定, 要先将其转换成前束范式. 例如下面的转换算法 1.<span class="math display">\[\begin{align*}&amp;\mathbf{Algorightm\;1\;:}\;\text{PRENEX}\\\\&amp;\mathbf{Input:}\quad\;\;\; \text{A quantified formula}\\&amp;\mathbf{Output:}\quad\text{A formula in prenex normal form}\\\\&amp;\;1.\;\text{Eliminate Boolean connectives other than } \vee,\wedge,\text{and } \neg.\\&amp;\;2.\;\text{Push negations to the right across all quantifiers,using De Morgan&#39;s rules}.\\&amp;\;3.\;\text{If there are name conflicts across scopes, solve byrenaming: give each variable}\\&amp;\quad\;\;\text{in each scope a unique name}.\\&amp;\;4.\; \text{Move quantifiers out by using equivalences such as}\\\\&amp;\hspace{25mm}\phi_1\land Qx.\phi_2(x)\LongleftrightarrowQx.(\phi_1\land\phi_2(x))\\&amp;\hspace{25mm}\phi_1\lor Qx.\phi_2(x)\LongleftrightarrowQx.(\phi_1\lor\phi_2(x))\\&amp;\hspace{25mm}Q_1y.\phi_1(y)\land Q_2x.\phi_2(x)\LongleftrightarrowQ_1y.Q_2x.(\phi_1(y)\land\phi_2(x))\\&amp;\hspace{25mm}Q_1y.\phi_1(y)\lor Q_2x.\phi_2(x)\LongleftrightarrowQ_1y.Q_2x.(\phi_1(y)\lor\phi_2(x))\\\\&amp;\;\;\;\;\ \text{where } Q,Q_1,Q_2\in\{\exists,\forall\}\;\text{arequantifiers},\; x\notin var(\phi_1),\;\text{and } y\notin var(\phi_2).\end{align*}\]</span></p><p>用一个例子说明该算法的执行过程. 考虑如下量化公式: <spanclass="math display">\[\mathcal{Q}:=\neg \exists x.\neg(\exists y.((y\Longrightarrow x)\land(\neg x\lor y))\land \neg \forall y,((y\land x)\lor (\neg x\land \negy))).\]</span> 在算法的第1,2步, 消除蕴含符号, 并将非运算符移到里边: <spanclass="math display">\[\forall x.(\exists y.((\neg y\lor x)\land (\neg x\lor y))\land \existsy.((\neg y\lor \neg x)\land (x\lor y))).\]</span> 算法第3步, 因为有两个量词作用在变量 <spanclass="math inline">\(y\)</span> 上, 所以要对其进行重命名: <spanclass="math display">\[\forall x.(\exists y_1.((\neg y_1\lor x)\land (\neg x\lor y_1))\land\exists y_2.((\neg y_2\lor \neg x)\land (x\lor y_2))).\]</span> 最后, 算法第4步, 将公式中的所有量词移到公式前面: <spanclass="math display">\[\forall x.\exists y_1.\exists y_2.(\neg y_1\lor x)\land (\neg x\lory_1)\land (\neg y_2\lor \neg x)\land (x\lor y_2).\]</span> 我们假定在量词消除算法中, 输入的公式为前束范式.</p><h2 id="量词消除算法quantifier-elimination-algorithm">2.2量词消除算法(<strong>quantifier elimination algorithm</strong>)</h2><p>量词消除算法的作用是将一个量化公式转换成等价的无量词的公式.并不是每一个理论都有对应的量词消除算法. 实际上,量词消除算法的存在通常意味着逻辑的可判定性,然而并非所有理论都是可判定的. 存在一个消除量词的程序是显而易见的.全称量词的消除可以向存在量词进行转换. 为此,我们定义了投影(<strong>projection</strong>)的一般概念,每个理论都必须具体化.</p><p><strong>投影</strong>. 变量 <span class="math inline">\(x\)</span>从具有 <span class="math inline">\(n\)</span>个量词的前束范式的量化公式的投影, <span class="math display">\[\mathcal{Q}_1=Q[n]V[n]...Q[2]V[2].\exists x.\phi,\]</span> 是一个公式 <span class="math display">\[\mathcal{Q}_2=Q[n]V[n]...Q[2]V[2].\phi&#39;\]</span> 其中<span class="math inline">\(x\notinvar(\phi&#39;)\)</span>, <span class="math inline">\(\phi,\phi&#39;\)</span> 都是无量词公式, 那么 <spanclass="math inline">\(\mathcal{Q}_1, \mathcal{Q}_2\)</span>逻辑上等价.</p><p>如下, 算法是用于消除前束范式中所有量词的 PROJECTION 算法.</p><p><span class="math display">\[\begin{align*}&amp;\mathbf{Algorithm\;2:}\; \text{QUANTIFIER-ELIMINATION}\\\\&amp;\mathbf{Input:}\quad \text{A sentence } Q[n]V[n]...Q[1]V[1].\phi,\;\text{where }\phi\;\text{is quantifier-free}\\&amp;\mathbf{Output:}\; \text{A (quantifier-free) formula over constants}\phi&#39;,\;\text{which is valid}\\&amp;\quad\quad\quad\quad\;\;\text{if and only if }\phi\;\text{isvalid}.\\\\&amp;\;1.\; \phi&#39;:=\phi;\\&amp;\;2.\; \mathbf{for}\; i:=1,...,n\; \mathbf{do}\\&amp;\;3.\; \quad\quad\mathbf{if}\; Q[i]=\exists\; \mathbf{then}\\&amp;\;4.\; \quad\quad\quad\quad \phi&#39;:=\;\; \text{PROJECT}(\;\;\phi&#39;, V[i]);\\&amp;\;5.\; \quad\quad\mathbf{else}\\&amp;\;6.\; \quad\quad\quad\quad \phi&#39;:=\neg\text{PROJECT}(\neg\phi&#39;, V[i]);\\&amp;\;7.\; \text{Return}\;\phi&#39;;\end{align*}\]</span></p><p>用两个例子说明量词消除算法的执行.</p><p><strong>量化布尔公式的量词消除</strong></p><p>我们可以运用二元解析的技术对量词进行消除. 下面举例说明, 考虑如下公式:<span class="math display">\[\begin{align*}&amp;\forall u_1.\forall u_2.\exists e_1.\forall u_3.\exists e_3.\existse_2.\\&amp;(u_1\lor \neg e_1)\land (\neg u_1\lor \neg e_2\lore_3)\land(u_2\lor \neg u_3\lor \neg e_1)\land(e_1\lor e_2)\land(e_1\lor\neg e_3).\end{align*}\]</span> 通过解析在 <span class="math inline">\(e_2\)</span>上的第二个和第四个子句得到: <span class="math display">\[\begin{align*}&amp;\forall u_1.\forall u_2.\exists e_1.\forall u_3.\exists e_3.\\&amp;(u_1\lor \neg e_1)\land (\neg u_1\lor \neg e_1\lore_3)\land(u_2\lor \neg u_3\lor \neg e_1)\land(e_1\lor \neg e_3).\end{align*}\]</span> 通过解析在 <span class="math inline">\(e_3\)</span>上的第二个和第四个子句得到: <span class="math display">\[\forall u_1.\forall u_2.\exists e_1.\forall u_3.(u_1\lor \neg e_1)\land (\neg u_1\lor e_1)\land(u_2\lor \neg u_3\lor\neg e_1).\]</span> 通过消除 <span class="math inline">\(u_3\)</span> 得到: <spanclass="math display">\[\forall u_1.\forall u_2.\exists e_1.(u_1\lor \neg e_1)\land (\neg u_1\lor e_1)\land(u_2\lor\neg e_1).\]</span> 通过解析在 <span class="math inline">\(e_1\)</span>上的第一个和第二个子句, 与第二个和第三个子句得到: <spanclass="math display">\[\forall u_1.\forall u_2.(u_1\lor \neg u_1)\land (\neg u_1\lor u_2).\]</span> 第一个子句是重言式, 因此可以直接移除. 接下来可以移除 <spanclass="math inline">\(u_1\)</span> 和 <spanclass="math inline">\(u_2\)</span>, 这将导致空的子句.因此该公式为假.</p><p><strong>量化析取线性演算的量词消除</strong></p><p>考虑如下量化的线性公式, <span class="math display">\[\forall x.\exists y.\exists z.(y+1\lex\hspace{1pc}\land\hspace{1pc}z+1\ley\hspace{1pc}\land\hspace{1pc}2x+1\le z).\]</span> 消除 <span class="math inline">\(z\)</span>, 得到: <spanclass="math display">\[\forall x.\exists y.(y+1\le x\hspace{1pc}\land\hspace{1pc}2x+1\le y-1).\]</span> 消除 <span class="math inline">\(y\)</span>, 得到: <spanclass="math display">\[\forall x.(2x+2\le x-1).\]</span> 将全称量词转变成存在量词得到: <span class="math display">\[\neg \exists x.\neg(2x+2\le x-1).\]</span> 化简得到: <span class="math display">\[\neg \exists x.x\gt -3.\]</span> 可见原公式为假.</p>]]></content>
    
    
    <categories>
      
      <category>判定过程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>量词消除</tag>
      
      <tag>量化公式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指针逻辑</title>
    <link href="/2022/05/e44910fffebb/"/>
    <url>/2022/05/e44910fffebb/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">1. 简介</h1><p>指针就是一个程序变量, 作用是指向其他程序结构.这里的程序结构可以是一个变量, 一个函数, 或者另一个指针. 同时,指针可以允许对一个数据集合进行操作来提升程序运行的效率.</p><p>指针能够工作的基础是因为计算机体系结构存在内存单元,而且这些内存单元有与之对应的地址或者说编号.指针的值无非就是内存单元的地址.而指针作用的方式就是这些内存单元寻址的方式, 称为内存模型(<strong>memorymodel</strong>).</p><p>内存模型描述的是关于内存单元寻址方式的假设.我们假定内存提供一块连续的统一的内存空间, 比如说地址空间集合 <spanclass="math inline">\(A\)</span> 用一个整数集合表示 <spanclass="math inline">\(\{0,...,N-1\}\)</span>.每一个地址都对应一个内存单元, 可以用来存储一个数据字(<strong>dataword</strong>). 数据字的集合记为 <span class="math inline">\(D\)</span>.一种映射关系内存取值(<strong>memoryvaluation</strong>)是从地址集合到数据字集合的映射.</p><p>编译器为每一个全局变量都分配一个特定的内存位置即地址.这种映射关系称为内存布局(<strong>memory layout</strong>). 内存布局 <spanclass="math inline">\(L:V\longrightarrow A\)</span> 是一个每一变量 <spanclass="math inline">\(v\in V\)</span> 到一个地址 <spanclass="math inline">\(a\in A\)</span> 的映射关系. 变量 <spanclass="math inline">\(v\)</span> 的地址称为自身的内存位置(memorylocation).</p><p>指针除了能够为变量静态分配内存空间,也能够为一些动态数据结构分配地址空间. 动态数据结构依赖于指定的内存区域,以供程序运行时创建的对象使用. 运行时库维护一个未使用内存区域的链表.该库中的一个函数, 分配一个指定大小的空间区域,并返回一个指向该内存区域开始(低地址)的指针. 因此,内存布局会在运行时发生相应的变化. 只要有足够的空间,内存分配就能够无限制地执行, 因此创建对象的数量理论上也是无上限的.在编程语言中, 实现这种内存分配的函数, 在 C 中是 <code>malloc()</code>,在 C++, C# 和 Java 中是 <code>new</code> 关键字. 相应,如果为了重用不再需要的数据结构所占用的内存, C 程序调用 free, C++ 调用<code>delete</code>, C# 和 Java 分别有自己的垃圾回收机制. 那么,动态对象的生命周期是其分配与释放之间的时间.</p><h1 id="简单的指针逻辑">2. 简单的指针逻辑</h1><p>指针逻辑的语法如下: <span class="math display">\[\begin{align*}formula\ &amp;:\ formula\land formula\ |\ \neg formula\ |\ (formula)\ |\atom\\atom\ &amp;:\ pointer = pointer\ |\ term = term\ |\ pointer &lt;pointer\|\ term &lt; term\\pointer\ &amp;:\ pointer-identifier\ |\ pointer + term\ |\ (pointer)\ |\\&amp;identifier\ \\&amp;\;|\;\&amp;*pointer\ |\ *pointer\ |\ NULL\\term\ &amp;:\ identifier\ |\ *pointer\ |\ term\ op\ term\ |\ (term)\ \\&amp;\;|\;integer\text{-}constant\ |\ identifier[term]\\op\ &amp;:\ +\ |\ -\end{align*}\]</span> 合法的指针逻辑公式:</p><ul><li><span class="math inline">\(*(p+i)=1\)</span>,</li><li><span class="math inline">\(*(p+*p)=0\)</span>,</li><li><span class="math inline">\(p=q\land *p=5\)</span>,</li><li><span class="math inline">\(*****p=1\)</span>,</li><li><span class="math inline">\(p\lt q\)</span>.</li></ul><p>不合法的指针逻辑公式:</p><ul><li><span class="math inline">\(p+i\)</span>,</li><li><span class="math inline">\(p=i\)</span>,</li><li><span class="math inline">\(*(p+q)\)</span>,</li><li><span class="math inline">\(*1=1\)</span>,</li><li><span class="math inline">\(p\lt i\)</span>.</li></ul><h1 id="堆数据结构的建模">3.堆数据结构的建模</h1><h2 id="链表">3.1 链表</h2><p>在程序中, 堆上分配的数据结构起着非常重要的作用,也是形成指针错误的重要原因.接下来说明如何通过指针逻辑去建模常用的数据结构.</p><p>在数组之后, 比较常见的动态分配的数据结构是链表.它通常是通过一种结构类型来实现的,该结构类型包含下一个指针的字段以及要存储在列表中的数据. 比如,下图所示的单向链表,</p><p><img src="\img\pointerlogic\Fig1.png" style="zoom:50%;"/></p><p>用递归定义的方式定义上面的单向链表中第 <spanclass="math inline">\(i\)</span> 个成员: <span class="math display">\[\begin{aligned}list\text{-}elem(p,0)&amp;\doteq p,\\list\text{-}elem(p,i)&amp;\doteq list\text{-}elem(p,i-1)\to n\ for\ i\ge1\end{aligned}\]</span> 接下来定义长度为 <span class="math inline">\(l\)</span>,以NULL指针结束的单向链表 <span class="math inline">\(list(p,l)\)</span>:<span class="math display">\[list(p,l)\doteq list\text{-}elem(p,l)=\rm NULL.\]</span> 如果是循环链表</p><p><img src="\img\pointerlogic\Fig2.png" style="zoom:50%;" /></p><p>定义为 <span class="math display">\[\begin{align*}c\_list(p,l)\doteq list\text{-}elem(p,l)=p.\end{align*}\]</span> 但是, 如上定义是不严谨的. 因为,如果只有一个元素的循环单链表也是符合如上定义的.</p><p><img src="\img\pointerlogic\Fig3.png" style="zoom:50%;" /></p><p>这是由于尽管我们打算指定存在 <span class="math inline">\(l\)</span>个不相交的链表元素, 但我们的定义并不能够排除共享链表元素的事实.这种性质通常称为分离性质(<em>separation properties</em>),断言链表元素不相交的一种方法是定义<strong>overlap</strong>, 如下所示:<span class="math display">\[overlap(p,q)\doteq p=q\lor p=q+1\lor p+1=q.\]</span> 由此可以声明链表元素彼此不相交: <span class="math display">\[\begin{aligned}list\text{-}disjoint(p,0)&amp;\doteq \rm TURE,\\list\text{-}disjoint(p,l)&amp;\doteq list\text{-}disjoint(p,l-1)\land\\&amp;\forall 0\le i\lt l-1.\neg overlap(list\text{-}elem(p,i),list\text{-}elem(p,l-1)).\end{aligned}\]</span></p><h2 id="树">3.2 树</h2><p>我们可以通过向数据结构的每个元素添加另一个指针域来实现二叉树.</p><p><img src="\img\pointerlogic\Fig4.png" style="zoom:50%;" /></p><p>上图所示的是二叉排序树, 我们用 <span class="math inline">\(l\)</span>表示左子树节点, <span class="math inline">\(r\)</span> 表示右子树节点.只要给定一个整数, 该二叉树能够在 <spanclass="math inline">\(O(h)\)</span> 时间复杂度内结束查询, 其中 <spanclass="math inline">\(h\)</span> 是树的高度. 同样地,二叉排序树的性质可以表示为: <span class="math display">\[\begin{aligned}(n.l\ne NULL\Longrightarrow n.l\to x\lt n.x)\\\land (n.r\ne NULL\Longrightarrow n.r\to x\gt n.x).\end{aligned}\]</span> 但是以上公式并不完整. 因此, 我们需要定义谓词 <spanclass="math inline">\(tree\text{-}reach(p,q)\)</span>, 如果 <spanclass="math inline">\(p\)</span> 能够在一步到达 <spanclass="math inline">\(q\)</span>, 那么该谓词为真. <spanclass="math display">\[tree\text{-}reach(p,q)\doteq p\ne NULL \land q\ne NULL\land \\(p=q\lor p\to l=q\lor p\to r =q).\]</span> 为了获得一个谓词, 该谓词在当且仅当 <spanclass="math inline">\(q\)</span> 在任意数量的步骤中可以从 <spanclass="math inline">\(p\)</span> 到达时才成立,我们需要定义一个给定二元关系 <span class="math inline">\(R\)</span>上的传递闭包(transitive closure).</p><p><strong>transitive closure</strong>: 给定一个二元关系 <spanclass="math inline">\(R\)</span>, 如果存在 <spanclass="math inline">\(z_1,...,z_n\)</span>, 那么存在关于 <spanclass="math inline">\(x,y\)</span> 的传递闭包: <spanclass="math display">\[xRz_1\land z_1Rz_2 \land...\land z_nRy.\]</span> 传递闭包可以形式化地递归定义如下: <spanclass="math display">\[\begin{aligned}TC_R^1(p,q)&amp;\doteq R(p,q),\\TC_R^i(p,q)&amp;\doteq \exists p&#39;.TC_R^{i-1}(p,p&#39;)\landR(p&#39;,q),\\TC(p,q)&amp;\doteq \exists i.TC^i_R(p,q).\end{aligned}\]</span> 利用 <span class="math inline">\(tree-reach\)</span>关系的传递闭包, 可以得到一个新的关系 <spanclass="math inline">\(tree-reach^*(p,q)\)</span>, 该关系成立当且仅当<span class="math inline">\(q\)</span> 从 <spanclass="math inline">\(p\)</span> 在任意步之内是可达的: <spanclass="math display">\[tree\text{-}reach^*(p,q)\Longleftrightarrow TC_{tree\text{-}reach}(p,q).\]</span> 所以可以扩展二叉排序树的性质: <span class="math display">\[(\forall p.tree-reach^*(n.l,p)\Longrightarrow p\to x\lt n.x)\\\land (\forall p.tree-reach^*(n.r,p)\Longrightarrow p\to x\gt n.x)\]</span></p><h1 id="基于规则的判定过程">4. 基于规则的判定过程</h1><p>指针逻辑所具有的表达能力可以对像链表, 树这样的数据结构建模,可以应用到基于规则的判定程序中去.</p><p>基本思想是, 定义一个指针逻辑的片段(fragment),对于特定类型数据结构(链表, 树)的谓词进一步对该指针逻辑进行修饰,还有一组足以证明在实践中产生的各种验证条件的证明规则.</p><p>首先对之前用于指定链表的 <spanclass="math inline">\(list\text{-}elem\)</span> 进行泛化,将结构中"next"指针域对其进行参数化. 假设 <em>f</em> 是一种结构的指针域.<span class="math inline">\(follow_n^f (q)\)</span> 代表的是, 指针<em>q</em> 沿着指针域 <em>f</em> 连续移动 <em>n</em> 次. <spanclass="math display">\[\begin{aligned}follow_0^f(p)&amp;\doteq p,\\follow_n^f(p)&amp;\doteq follow_{n-1}^f(p)\to f.\end{aligned}\]</span> 如果 <span class="math inline">\(follow_n^f (p)=q\)</span>成立, 就说指针 <em>p</em> 沿着指针域 <em>f</em> 的方向移动 <em>n</em>次之后能够到达(reach) <em>q.</em> 可以用类似链表形式的谓词对此进行说明:<span class="math display">\[p\xrightarrow[x]{f}q\]</span> 上面的谓词称作可达性谓词(reachability predicate). 可以用follow() 将其形式化为: <span class="math display">\[p\xrightarrow[x]{f}\Longleftrightarrow \exists n.(follow_n^f(p)=q\land\forall m\lt n.follow_m^f(p)\ne x).\]</span> 考虑如下程序验证问题.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-keyword">int</span> payload;<br>&#125;*<span class="hljs-built_in">list</span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(struct S *p; p!=<span class="hljs-number">0</span>; p=p-&gt;next)&#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;payload == a)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以用如下公式说明上述例程返回结果的正确性 <spanclass="math display">\[find(a)\Longleftrightarrow \existsp&#39;.(list\xrightarrow[0]{next}p&#39;\land p&#39;\to payload=a).\]</span> 如果以下两个条件满足则说明 find(a) 为真:</p><ul><li><p>在指针域的方向上,存在一个链表元素在不经过NULL指针的情况下是可达的;</p></li><li><p>该链表元素的值等于 a.</p></li></ul><p>循环体开始的不变式定义为 <strong>INV</strong>: <spanclass="math display">\[{\mathbf{\rm INV}}:=list\xrightarrow[0]{next}p\land (\forall q\nep.list\xrightarrow[p]{next}q\Longrightarrow q\to payload\ne a).\]</span> 程序执行过程中, 保持循环不变式的性质; 同时,INV能够蕴涵这种特性. 形式化地, 这种性质可以用四个验证条件表明.所有验证条件的有效性能够说明循环不变式的性质. <spanclass="math display">\[\begin{aligned}{\rm \mathbf{IND\text{-}BASE}}&amp;:=p=list \Longrightarrow {\rm\mathbf{INV}}\\{\rm \mathbf{IND\text{-}STEP}}&amp;:=({\rm \mathbf{INV}}\land p\topayload\ne a)\Longrightarrow {\rm \mathbf{INV}}[p/p\to next]\\{\rm \mathbf{VC\text{-}P1}}&amp;:=({\rm \mathbf{INV}}\land p\topayload=a)\\&amp;\Longrightarrow \existsp&#39;.(list\xrightarrow[0]{next}p&#39;.p&#39;\to payload=a)\\{\rm \mathbf{VC\text{-}P2}}&amp;:=({\rm \mathbf{INV}}\landp=0)\Longrightarrow \neg \existsp&#39;.(list\xrightarrow[0]{next}p&#39;.p&#39;\to payload=a)\end{aligned}\]</span> 证明这些验证条件的正确性, 就可表明程序满足所要求的性质.</p><p>判定可达性谓词公式</p><p>以验证条件 <strong>IND-BASE</strong> 为例 <spanclass="math display">\[\begin{aligned}&amp;p=list \Longrightarrow {\rm \mathbf{INV}}\\&amp;\Longleftrightarrow p=list \Longrightarrowlist\xrightarrow[0]{next}p\land (\forall q\nep.list\xrightarrow[p]{next}q\Longrightarrow q\to payload\ne a)\\&amp;\Longleftrightarrow list\xrightarrow[0]{next}list\land (\forallq\ne list.list\xrightarrow[list]{next}q\Longrightarrow q\to payload\nea)\\&amp;\Longleftrightarrow (\exists n.follow_n^{next}(list)=list\land\forall m\lt n.follow_m^{next}(list)\ne list)\land\\&amp;\quad\quad\;\;(\forall q\ne list.((\existsn.follow_n^{next}(list)=q\land \forall m\lt n.follow_m^{next}(list)\nelist)\\&amp;\quad\quad\;\Longrightarrow q\to payload\ne a)).\end{aligned}\]</span> 证明如下可达性谓词的有效性 <span class="math display">\[list\xrightarrow[0]{next}list\land (\forall q\nelist.list\xrightarrow[list]{next}q\Longrightarrow q\to payload\ne a)\]</span> 即证 <span class="math display">\[(\forall q\ne list.list\xrightarrow[list]{next}q\Longrightarrow q\topayload\ne a)\]</span> 引入 <strong>Skolem</strong> 变量, 消除全称量词 <spanclass="math display">\[(q&#39;\ne list\land list\xrightarrow[list]{next}q&#39;\Longrightarrowq&#39;\to payload\ne a)\]</span> 因为 <spanclass="math inline">\(list\xrightarrow[list]{next}q&#39;\Longleftrightarrow list=q&#39;\)</span>, 所以蕴涵式的左边为假,整体为真, 原式得证.</p>]]></content>
    
    
    <categories>
      
      <category>判定过程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>指针逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组理论 (二)</title>
    <link href="/2022/05/28e00f7e9070/"/>
    <url>/2022/05/28e00f7e9070/</url>
    
    <content type="html"><![CDATA[<h1 id="数组理论延迟编码过程">数组理论延迟编码过程</h1><h2 id="基于dpllt的增量编码">1. 基于DPLL(<spanclass="math inline">\(T\)</span>)的增量编码</h2><p><a href="https://socod.github.io/ArrayIntro/">数组理论(一)</a>说明了一种通过规约程序来实现将数组理论编码成带有索引下标和元素的理论.本质上,它是通过添加读写覆盖规则和扩展性规则的实例来实现的.实际上,算法生成的大多数实例都是不必要的,也就增加了判定问题的计算成本. 所以要讨论一种新的程序或者算法,该算法增量的生成读写覆盖和扩展性规则的实例. 设计该算法是为了能够集成到DPLL(<span class="math inline">\(T\)</span>) 程序中去.它使用未解释函数将数组公式延迟编码为等式逻辑.该算法假定索引理论是无量词的, 但是确实允许数组之间的相等性.</p><p><em>预处理</em></p><p>我们在算法主要阶段之前执行预处理步骤.预处理步骤详尽地实例化了读覆盖写规则的前半部分, 比如说,对于公式中存在的所有的表达式 <span class="math inline">\(a\{i\leftarrowe\}\)</span>, 添加相应的约束 <span class="math display">\[a\{i\leftarrow e\}[i]= e.\]</span> 因此, 这就产生了线性数量的约束.读覆盖写公理的第二种情况和扩展性规则将逐步实施.</p><p>在介绍增量编码之前, 简要地对DPLL(<spanclass="math inline">\(T\)</span>) 的基本原则进行说明. 在 DPPL(<spanclass="math inline">\(T\)</span>) 中, 命题 SAT求解器用于获取公式中理论原子的(可能是部分)布尔赋值.该赋值被传递给理论求解器, 该理论求解器确定该赋值是否为 <spanclass="math inline">\(T-consistent\)</span>.理论求解器可以将添加的命题约束传递回 SAT 求解器,以实现理论传播和理论学习. 这些约束将添加到由 SAT求解器维护的子句数据库中. 然后, 该过程将迭代进行, 要么确定公式为 UNSAT,要么生成新的(可能是部分的)布尔赋值.</p><h2 id="读覆盖写公理的延迟实例化">2. 读覆盖写公理的延迟实例化</h2><p>如下算法将一个数组公式的文字(也就是数组理论的原子)的集合作为输入.文字的合取式记为 <span class="math inline">\(\hat{Th}\)</span>. 如果<span class="math inline">\(\hat{Th}\)</span> 是一致性的(为真),算法返回<span class="math inline">\(\rm TRUE\)</span>;否则返回一个在该数组理论下为真的公式 <spanclass="math inline">\(t\)</span>, 并且禁用之前的赋值 <spanclass="math inline">\(\hat{Th}\)</span>. 公式 <spanclass="math inline">\(t\)</span> 初始化为 <spanclass="math inline">\(\rm TRUE\)</span>,并且随着算法的执行会增强公式的正确性.</p><p><span class="math display">\[\begin{aligned}&amp;\mathbf{Algorithm\ 1:}\ \text{ARRAY-ENCODING-PROCEDURE}\\&amp;\mathbf{Input:}\quad\quad \text{A conjunction of array literals }\hat{Th}\\&amp;\mathbf{Output:}\quad\; \text{TRUE, or a valid array formula } t\\text{that blocks } \hat{Th}\\\\&amp;1.\; t:=\text{TRUE};\\&amp;2.\; \text{Compute equivalence classes of terms in } \hat{Th};\\&amp;3.\; \text{Construct the weak equivalence graph } G\ \text{from }\hat{Th};\\&amp;4.\; \mathbf{for}\; a,b,i,j\; \text{such that } a[i]\;\text{and}\;b[j]\ \text{are terms in } \hat{Th}\; \mathbf{do}\\&amp;5.\;\quad\quad \mathbf{if}\; i\approx j\; \mathbf{then}\\&amp;6.\;\quad\quad\quad\; \mathbf{if}\ a[i]\not\approx b[j]\\mathbf{then}\\&amp;7.\;\quad\quad\quad\quad\; \mathbf{for}\;\text{each simple path }p\in G\ \text{from } a\;\text{to } b\; \mathbf{do}\\&amp;8.\;\quad\quad\quad\quad\quad\; \mathbf{if}\; \text{each label }l\; \text{on } p\text{&#39;s edges satisfies } l\neq i\;\mathbf{then}\\&amp;9.\;\quad\quad\quad\quad\quad\quad\; t:=t\wedge ((i=j\wedgeCond_i(p))\Longrightarrow a[i]=b[j]);\\&amp;10.\; \mathbf{return}\;t;\end{aligned}\]</span></p><p>算法1 第2行中 <span class="math inline">\(\hat{Th}\)</span>提到的等价类会被计算出来. 之前已经说过如何使用同余闭包算法计算等价类.我们用 <span class="math inline">\(t_1\approx t_2\)</span> 表示项 <spanclass="math inline">\(t_1\)</span> 和 <spanclass="math inline">\(t_2\)</span> 在同一个等价类中.</p><p>算法1 第3行构造了一个带有标记的无向图 <spanclass="math inline">\(G(V,E)\)</span>, 称作弱等价图(<strong>weakequivalence graph</strong>). 顶点集 <spanclass="math inline">\(V\)</span> 对应 <spanclass="math inline">\(\hat{Th}\)</span> 中的数组项. 边集是有可选的标记,并添加如下:</p><ol type="1"><li>对于数组项之间的每个等式 <span class="math inline">\(a = b\)</span>,在 <span class="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 之间添加一个未标记的边.</li><li>对于每个数组项 <span class="math inline">\(a\)</span>和对于该项的更新 <span class="math inline">\(a\{i\leftarrowv\}\)</span>, 在其顶点之间添加标记为 <spanclass="math inline">\(i\)</span> 的边.</li></ol><p>以下用一个例子进行说明. 考虑如下公式 <span class="math display">\[\begin{align*}\hat{Th}&amp;\doteq i\ne j \land i\ne k\land a\{j\leftarrow v\}=b \landa\{k\leftarrow w\}\\ &amp;= c\land b[i]\ne c[i].\tag{2.1}\end{align*}\]</span> <span class="math inline">\(\hat{Th}\)</span>对应的弱等价图为:</p><p><img src="\img\ArrayEncod\Fig1.png" style="zoom:50%;" /></p><p>每当 <span class="math inline">\(G\)</span> 中存在从 <spanclass="math inline">\(a\)</span> 到 <spanclass="math inline">\(b\)</span> 的路径时, 两个数组 <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 称为弱等效项(<strong>weaklyequivalent</strong>). 这意味着它们在所有数组元素上均相等,除了可能在路径上更新的元素之外. 上例中的数组 <spanclass="math inline">\(a, b\)</span> 和 <spanclass="math inline">\(c\)</span> 都是弱等价的.</p><p>算法1 第4-9行生成了增强数组元素等价性的约束. 这与 <spanclass="math inline">\(\hat{Th}\)</span> 中的任何一对数组元素项 <spanclass="math inline">\(a[i]\)</span> 和 <spanclass="math inline">\(b[j]\)</span> 有关. 根据等价类, 其中索引项 <spanclass="math inline">\(i\)</span> 和 <spanclass="math inline">\(j\)</span> 必须是相等的, 但是 <spanclass="math inline">\(a[i]\)</span> 和 <spanclass="math inline">\(b[j]\)</span> 不相等. 这个想法是确定数组 <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 是否通过不使用索引 <spanclass="math inline">\(i\)</span> 的数组更新链进行连接.如果存在具有此属性的链, 那么 <span class="math inline">\(a[i]\)</span>肯定等于 <span class="math inline">\(b[j]\)</span>. 我们将使用弱等价图<span class="math inline">\(G\)</span> 检查这个链是否存在. 我们将考虑从<span class="math inline">\(a\)</span> 到 <spanclass="math inline">\(b\)</span> 的所有路径 <spanclass="math inline">\(p\)</span>. 如果根据我们的等价类,路径中的任何一条边标签的索引等于 <span class="math inline">\(i\)</span>,那么就可以丢弃该路径. 否则, 我们就找到了所需的链, 并将 <spanclass="math display">\[(i=j \land Cond_i(p))\Longrightarrow a[i]=b[j]\]</span> 作为约束条件加入到 <span class="math inline">\(t\)</span> 中.表达式 <span class="math inline">\(Cond_i(p)\)</span>是以下合取的约束:</p><ol type="1"><li>对于从 <span class="math inline">\(a\)</span> 到 <spanclass="math inline">\(b\)</span> 的未标记边, 添加约束 <spanclass="math inline">\(a=b\)</span>.</li><li>对于添加了标记 <span class="math inline">\(k\)</span> 的边, 添加约束<span class="math inline">\(i\ne k\)</span>.</li></ol><p>继续上面的例子, 我们有两个非平凡的等价类: <spanclass="math inline">\(\{a\{j\leftarrow v\}, b\}\)</span> 和 <spanclass="math inline">\(\{a\{k\leftarrow w\}, c\}\)</span>. 因此, 项 <spanclass="math inline">\(b[i], c[i]\)</span> 满足 <spanclass="math inline">\(b[i]\ne c[i]\)</span>, 而且它们的索引是大致相等的.在图 <span class="math inline">\(G\)</span> 上有一条从 <spanclass="math inline">\(b\)</span> 到 <spanclass="math inline">\(c\)</span> 的路径 <spanclass="math inline">\(p\)</span>, 它的边都没有标注与 <spanclass="math inline">\(i\)</span> 相同的等价类的索引, 即 <spanclass="math inline">\(j\ne i, k\ne i\)</span>. 对于这条路径 <spanclass="math inline">\(p\)</span>, 可以得到 <span class="math display">\[Cond_i(p) = i\ne j\land j\ne k\]</span> 然后将第9行中的 <span class="math inline">\(t\)</span> 更新为<span class="math display">\[t:= (i=i\land i\ne j\land i=k)\Longrightarrow b[i]=c[i].\]</span> 现在 上面的 <span class="math inline">\(t\)</span>被添加到上面的公式 2.1 中了. <span class="math inline">\(t\)</span>左边显然成立, 由此我们推出一个与 <span class="math inline">\(b[i]\nec[i]\)</span> 矛盾的条件. 因此, 我们证明了最初例子的不可满足性.</p><p>应当注意, 当没有这样一种链接的时候, 上述算法返回的约束为 <spanclass="math inline">\(\rm TRUE\)</span>. 在这种情况下, 数组理论 <spanclass="math inline">\(\hat{Th}\)</span> 是可满足的. 否则, <spanclass="math inline">\(t\)</span> 就是一个封锁子句(<strong>blockingclause</strong>), 也就是说, <span class="math inline">\(t\)</span>的命题骨架与 <span class="math inline">\(\hat{Th}\)</span> 的是不一致的.这样就保证了 <span class="math inline">\(DPLL(T )\)</span>程序的命题部分的进展.</p><h2 id="扩展规则的延迟实例化">3. 扩展规则的延迟实例化</h2><p>前面所示算法生成的约束足以蕴涵各个数组元素之间所需的等价性.为了获得可扩展数组理论的完整判定程序,我们需要添加蕴涵整个数组之间相等的约束. 除了执行前一小节的算法,还应执行下述算法, 它产生进一步的约束, 蕴涵数组项的相等性.</p><p><span class="math display">\[\begin{aligned}&amp;\mathbf{Algorithm\ 2:}\ \text{EXTENSIONAL-ARRAY-ENCODING}\\&amp;\mathbf{Input:}\quad\quad \text{A conjunction of array literals }\hat{Th}\\&amp;\mathbf{Output:}\quad\; \text{TRUE, or a valid array formula } t\\text{that blocks } \hat{Th}\\\\&amp;1.\; t:=\text{TRUE};\\&amp;2.\; \text{Compute equivalence classes of terms in } \hat{Th};\\&amp;3.\; \text{Construct the weak equivalence graph } G\ \text{from }\hat{Th};\\&amp;4.\; \mathbf{for}\; a,b\; \text{such that } a\;\text{and}\; b\\text{are terms in } \hat{Th}\; \mathbf{do}\\&amp;5.\;\quad \mathbf{if}\; a\not\approx b\; \mathbf{then}\\&amp;6.\;\quad\quad\; \mathbf{for}\;\text{each simple path } p\in G\\text{from } a\;\text{to } b\; \mathbf{do}\\&amp;7.\;\quad\quad\quad\quad \text{Let } S\; \text{be the set of edgelabels of }p;\\&amp;8.\;\quad\quad\quad\quad t:=t\wedge (\bigwedge_{i\inS}Cond_i^u(p)\Longrightarrow a=b);\\&amp;9.\; \mathbf{return}\;t;\end{aligned}\]</span></p><p>推导两个数组项之间的相等性如下: 考虑 <spanclass="math inline">\(\hat{Th}\)</span> 中所用不相等的数组项 <spanclass="math inline">\(a,b\)</span>, 以及 <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 之间的任何相等链. 选择一个这样的链,我们将其称为 <span class="math inline">\(p\)</span>, 并令 <spanclass="math inline">\(S\)</span>为该链中数组更新中使用的所有不同索引的集合. 对于所有索引 <spanclass="math inline">\(i\in S\)</span>, 执行以下操作:</p><ol type="1"><li>在 <span class="math inline">\(p\)</span> 的第一个边上找到以 <spanclass="math inline">\(i\)</span> 或索引 <spanclass="math inline">\(j\)</span> 使得 <spanclass="math inline">\(j\approx i\)</span> 的数组项. 用 <spanclass="math inline">\(first\)</span> 表示该数组项, .并用 <spanclass="math inline">\(p&#39;\)</span> 表示该边之前的路径 <spanclass="math inline">\(p\)</span> 的前缀.</li><li>找到在最近一次更新后的数组项, 该数组标有 <spanclass="math inline">\(i\)</span> 或索引 <spanclass="math inline">\(k\)</span>, 使得 <spanclass="math inline">\(k\approx i\)</span>. 用 <spanclass="math inline">\(last\)</span> 表示该数组项, 并用 <spanclass="math inline">\(p&#39;&#39;\)</span> 表示该边之后的路径 <spanclass="math inline">\(p\)</span> 的后缀.</li><li>检查 <span class="math inline">\(fist[i]\)</span> 与 <spanclass="math inline">\(last[i]\)</span> 是否相等.</li></ol><p>如果这适用于所有索引, 则 <span class="math inline">\(a\)</span>必等于 <span class="math inline">\(b\)</span>. <spanclass="math inline">\(G\)</span> 中的这种链具有以下形式:</p><p><img src="\img\ArrayEncod\Fig2.png" style="zoom:50%;" /></p><p>算法2 使用图 <span class="math inline">\(G\)</span>来检查是否存在这样的链, 如下所述: 它考虑了从 <spanclass="math inline">\(a\)</span> 到 <spanclass="math inline">\(b\)</span> 的所有路径 <spanclass="math inline">\(p\)</span>. 对于每个路径 <spanclass="math inline">\(p\)</span>, 它计算集合 <spanclass="math inline">\(S\)</span>. 然后将 <span class="math display">\[\bigwedge_{i\in S}Cond_i^u(p)\Longrightarrow a=b\]</span></p><p>作为约束添加到 <span class="math inline">\(t\)</span> 中, 其中 <spanclass="math inline">\(Cond_i^u(p)\)</span> 的定义如下: 如果在 <spanclass="math inline">\(p\)</span> 中没有边的索引标签等于 <spanclass="math inline">\(i\)</span>, 则为 <span class="math display">\[Cond_i^u(p):=Cond_i(p).\]</span> 否则, 这是索引 <span class="math inline">\(i\)</span> 在 <spanclass="math inline">\(p\)</span> 上的更新满足上述约束的条件, 其形式如下:<span class="math display">\[Cond_i^u(p):=Cond_i(p&#39;)\land first[i]=last[i]\landCond_i(p&#39;&#39;).\]</span> 考虑输入到算法2 的公式: <span class="math display">\[\hat{Th}:=v=w \land b=a\{i\leftarrow v\}\land b\ne a\{i\leftarrow w\}.\]</span> 上式具有不一致性. 预处理步骤是添加读写公理的第一部分的实例.对于 <span class="math inline">\(\hat{Th}\)</span> 中的理论文字,我们可得 <span class="math display">\[a\{i\leftarrow v\}[i]=v\ {\rm and}\ a\{i\leftarrow w\}[i]=w.\]</span> 接下来, 构造如下的弱等价图:</p><p><img src="\img\ArrayEncod\Fig3.png" style="zoom:50%;" /></p><p>除其他外, 算法2 将 <span class="math inline">\(b\)</span> 和 <spanclass="math inline">\(a\{i\leftarrow w\}\)</span> 标识为数组项.它们之间只有一条路径, 并且该路径的集合 <spanclass="math inline">\(S\)</span> 是关于 <spanclass="math inline">\(\{i\}\)</span> 的单例图. 数组项的 <spanclass="math inline">\(first\)</span> 是 <spanclass="math inline">\(a\{i\leftarrow v\}\)</span>, 数组项的 <spanclass="math inline">\(last\)</span> 是 <spanclass="math inline">\(a\{i\leftarrow w\}\)</span>. 请注意, <spanclass="math inline">\(p&#39;\)</span> 是从 <spanclass="math inline">\(b\)</span> 到 <spanclass="math inline">\(a\{i\leftarrow v\}\)</span> 的路径, 而 <spanclass="math inline">\(p&#39;&#39;\)</span> 为空. 我们可得 <spanclass="math display">\[Cond_i^u(p)=(a\{i\leftarrow v\}[i]=a\{i\leftarrow w\}[i])\]</span> 然后添加约束 <span class="math display">\[a\{i\leftarrow v\}[i]=a\{i\leftarrow w\}[i]\Longrightarrowb=a\{i\leftarrow w\}\]</span> 到公式中去. 回想一下, 我们已经添加了约束 <spanclass="math inline">\(a\{i\leftarrow v\}[i]=v\)</span> 和 <spanclass="math inline">\(a\{i\leftarrow w\}[i]=w\)</span>并假定在公式的所有模型中 <span class="math inline">\(v = w\)</span>.等式逻辑的判定程序将确定 <span class="math inline">\(a\{i\leftarrowv\}[i]=a\{i\leftarrow w\}[i]\)</span> 成立, 因此 <spanclass="math inline">\(DPLL(T)\)</span> 将推断出 <spanclass="math inline">\(b=a\{i\leftarrow w\}\)</span>在该公式的任何模型中都必须为真, 这与原公式 <spanclass="math inline">\(\hat{Th}\)</span> 的第三个文字矛盾.<code>Qed</code></p>]]></content>
    
    
    <categories>
      
      <category>判定过程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>数组判定</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>悠泥客指针</title>
    <link href="/2022/05/d9b2728991b4/"/>
    <url>/2022/05/d9b2728991b4/</url>
    
    <content type="html"><![CDATA[<h1 id="unique_ptr">unique_ptr</h1><h2 id="简介">1. 简介</h2><p><font face="Helvetica">C++</font>为编程人员提供了3种智能指针--<font face="Helvetica">std::shared_ptr,std::unique_ptr, std::weak_ptr</font>. 本文先介绍<font face="Helvetica">std::unique_ptr</font>,该类型的指针能够管理堆上的对象, 同时在适当时候(作用域外)释放内存.应当说明 <font face="Helvetica">unique_ptr</font> 定义在头文件<font face="Helvetica"><memory></font> 中. 下面是其模板的定义:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>,</span><br><span class="hljs-class">    <span class="hljs-keyword">class</span> <span class="hljs-title">Deleter</span> =</span> std::default_delete&lt;T&gt;<br>&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">unique_ptr</span>;</span><br><span class="hljs-comment">///</span><br><span class="hljs-keyword">template</span>&lt;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>,</span><br><span class="hljs-class">    <span class="hljs-keyword">class</span> <span class="hljs-title">Deleter</span></span><br><span class="hljs-class">&gt;</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">unique_ptr</span>&lt;</span>T[], Deleter&gt;;<br></code></pre></td></tr></table></figure> 当如下操作之一执行的时候, 使用对应的删除器将对象释放:</p><ol type="1"><li><font face="Helvetica">unique_ptr</font> 所管理的对象被销毁</li><li>通过重写的赋值运算 <font face="Helvetica">operator=</font> 或者公有成员函数 <font face="Helvetica">reset()</font> 将<font face="Helvetica">unique_ptr</font> 管理的对象赋给其他指针.</li></ol><p>调用 <code>get_deleter()(ptr)</code> 使用用户提供的删除器释放<font face="Helvetica">unique_ptr</font> 对象. 默认的删除器要使用<code>delete</code> 运算符来销毁对象并释放对象占据的内存.</p><p>当然, <font face="Helvetica">unique_ptr</font> 也可以不指向任何对象,此时即为空.</p><p><font face="Helvetica">unique_ptr</font> 管理对象的方法有两种:</p><ol type="1"><li>使用 <code>new</code> 创建单个对象</li><li>使用 <code>new[]</code>管理动态分配的对象数组(释放内存也要使用对应的删除器).</li></ol><div class="note note-info">            <p>优雅使用 <font face="Helvetica">unique_ptr</font> 的注意事项:</p>          </div><p>可以想见的是, 对象所有权只能在 <code>non-const</code><font face="Helvetica">unique_ptr</font> 之间进行转移. 如果对象是由<code>const std::unique_str</code> 来管理的, 那该对象只受作用域的限制.<font face="Helvetica">unique_ptr</font> 通常用来管理对象的生存期,包括:</p><ol type="1"><li>通过确保在(程序)正常退出和抛出异常退出两种情况下都能正常删除对象,为处理具有动态生存期的对象的类或者函数提供一种异常安全的机制.</li><li>将独占的具有动态生存期的对象传递到函数中.</li><li>从函数获取独占的具有动态生存期的对象.</li><li>可以作为可移动容器的元素类型, 比如保有指向动态分配对象的指针的容器<font face="Helvetica">std::vector</font>.</li></ol><p><font face="Helvetica">std::unique_ptr</font> 可为不完整类型 T 构造,例如可以用于改善 <ahref="https://en.cppreference.com/w/cpp/language/pimpl">plmpl</a>方法中句柄的用途. 若使用默认删除器, 在调用点处, T 必须是完整的类型,例如在调用析构函数, 使用移动赋值运算符以及调用<font face="Helvetica">std::unique_ptr</font> 的成员函数<font face="Helvetica">reset()</font> 的时候. 相反地, 不能将<font face="Helvetica">std::shared_ptr</font> 从原始指针 (raw pointer)构造成不完整类型, 但是当 T 是不完整类型时可以被销毁. 应当注意的是, 如果T 是一个类模板的特化, 则 <font face="Helvetica">std::unique_ptr</font>作为操作数使用, 比如, 由于所谓的 Argument-dependent lookup (ADT),<code>!p</code> 要求 T 的参数必须是完整类型.</p><p>如果 T 是 B 的派生类, 那么 <code>std::unique_ptr&lt;T&gt;</code>是可以隐式转换成 <code>std::unique_ptr&lt;B&gt;</code> 的.经过隐式转换后形成的 <code>std::unique_ptr&lt;B&gt;</code>的默认删除器将会调用 B 自身的删除器 (<code>delete</code>, 或者<code>delete[]</code>), 这将会导致未定义的行为 (undefined behavior),除非 B 的析构函数是虚函数. 还应当注意的是,<font face="Helvetica">std::shared_ptr</font> 就不同了, 转换后的<code>std::shared_ptr&lt;B&gt;</code> 将仍旧使用 T 的删除器, 不论 B的析构是否为虚函数, 也会正确删除被占有对象.</p><p>不同于 <font face="Helvetica">std::shared_ptr</font>,<font face="Helvetica">std::unique_ptr</font> 能够通过任何满足<em>NullablePointer</em> 的自定义句柄类型管理对象. 这就允许,通过提供宏定义指针 <font face="Helvetica">boost::offset_ptr</font>或者其他奇特指针 (fancy pointer -- 提供指针抽象的指针) 的删除器,来管理位于共享内存中的对象.</p><h2 id="示例">2. 示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cassert&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-comment">// 说明运行时多态机制的基类</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">B</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B::bar\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">D</span> :</span> B<br>&#123;<br>  <span class="hljs-built_in">D</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;D::D\n&quot;</span>; &#125;<br>  ~<span class="hljs-built_in">D</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;D::~D\n&quot;</span>; &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;D::bar\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 接收 unique_ptr 为参数, 可以是值传递, 也可以是右值引用传递</span><br><span class="hljs-function">std::unique_ptr&lt;D&gt; <span class="hljs-title">pass_through</span><span class="hljs-params">(std::unique_ptr&lt;D&gt; p)</span></span><br><span class="hljs-function"></span>&#123;<br>  p-&gt;<span class="hljs-built_in">bar</span>();<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;1) Unique ownership semantics demo\n&quot;</span>;<br>  &#123;<br>    <span class="hljs-comment">// 创建一个 p 独占的对象</span><br>    std::unique_ptr&lt;D&gt; p = std::make_unique&lt;D&gt;();<br><br>    <span class="hljs-comment">// 通过函数 pass_through 转移所有权</span><br>    std::unique_ptr&lt;D&gt; q = <span class="hljs-built_in">pass_through</span>(std::<span class="hljs-built_in">move</span>(p));<br><br>    <span class="hljs-comment">// `p` 现在为 `nullptr`</span><br>    <span class="hljs-built_in">assert</span>(!p);<br>  &#125;<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span><br>               <span class="hljs-string">&quot;2) Runtime polymorphism demo\n&quot;</span>;<br>  &#123;<br>    <span class="hljs-comment">// 创建一个基类型的指针p, 指向派生类型的对象</span><br>    std::unique_ptr&lt;B&gt; p = std::make_unique&lt;D&gt;();<br><br>    <span class="hljs-comment">// 运行时多态, 因为指向的是派生类的对象</span><br>    <span class="hljs-comment">// 理应调用派生类的成员函数</span><br>    p-&gt;<span class="hljs-built_in">bar</span>();<br>  &#125;<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span><br>               <span class="hljs-string">&quot;3) Array form of unique_ptr demo\n&quot;</span>;<br>  &#123;<br>    <span class="hljs-function">std::unique_ptr&lt;D[]&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> D[<span class="hljs-number">3</span>])</span></span>;<br>  &#125; <span class="hljs-comment">// 析构 ~D() 会被调用三次</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出: <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">1) Unique ownership semantics demo<br>D::D<br>D::bar<br>D::~D<br><br>2) Runtime polymorphism demo<br>D::D<br>D::bar<br>D::~D<br><br>3) Array form of unique_ptr demo<br>D::D<br>D::D<br>D::D<br>D::~D<br>D::~D<br>D::~D<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>智能指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组理论 (一)</title>
    <link href="/2022/04/eb1812b5cb5f/"/>
    <url>/2022/04/eb1812b5cb5f/</url>
    
    <content type="html"><![CDATA[<h1 id="数组">1. 数组</h1><p>现代多数编程语言都对数组类型提供了支持,并且数组在对像内存这样的硬件组件建模时也会用到.所以对硬件系统的分析就要求能够对包含数组的公式进行判定.首先说明如何用数组理论对一个循环不变式进行判定.</p><p>考虑如下伪代码片段: <span class="math display">\[\begin{aligned}&amp;a: \mathbf{array}\ 0..99\ \mathbf{of\ integer;}\\&amp;i: \mathbf{integer;}\\\\&amp;\mathbf{for}\ \rm i:=0\ \mathbf{to}\ 99\ \mathbf{do}\\&amp;\hspace{2cm} \mathbf{assert} (\forall x\in \mathbb{N}_0.x\lti\Longrightarrow a[x]=0);\\&amp;\hspace{2cm} \rm a[i]:=0;\\&amp;\hspace{2cm} \mathbf{assert}(\forall x\in \mathbb{N}_0.x\le i\Longrightarrow a[x]=0);\\&amp;\mathbf{done;}\\&amp;\mathbf{assert}(\forall x\in \mathbb{N}_0.x\le 99 \Longrightarrowa[x]=0);\end{aligned}\]</span> 正确性论证的主要步骤是在执行循环体内的赋值时,证明赋值之后的断言是从赋值前的断言中产生的.通常的做法是生成验证条件(<strong>verification conditions</strong>),比如说, 使用霍尔公理系统(Hoare's axiom system). 能够得到如下的验证条件:<span class="math display">\[\begin{gather*}(\forall x\in \mathbb{N}_0.x\lt i\Longrightarrow a[x]=0) \\\land a&#39;=a\{i\leftarrow 0\}\\\Longrightarrow (\forall x\in \mathbb{N}_0.x\le i \Longrightarrowa&#39;[x]=0).\tag{f.1}\end{gather*}\]</span></p><p>数组理论允许对数组进行公式化的表达, 数组被形式化为从索引类型(indextype)到元素类型(element type)的映射. 用 <spanclass="math inline">\(T_I\)</span> 表示索引类型, <spanclass="math inline">\(T_E\)</span>表示元素类型. 数组自身的类型表示为<span class="math inline">\(T_A\)</span>, 也就是 <spanclass="math inline">\(T_I \rightarrow T_E\)</span> 的简写形式, 比如说,将 <span class="math inline">\(T_I\)</span> 的一个元素映射到 <spanclass="math inline">\(T_E\)</span> 的一个元素的函数的集合.索引集和元素集都不需要是有限的.</p><p>令 <span class="math inline">\(a\in T_A\)</span> 表示一个数组.有两个基本的数组操作:</p><ol type="1"><li>从 <span class="math inline">\(a\)</span> 中读取一个下标为 <spanclass="math inline">\(i\in T_I\)</span> 的元素. 下标为 <spanclass="math inline">\(i\)</span> 的元素的值表示为 <spanclass="math inline">\(a[i]\)</span>. 该运算符称作数组索引运算符.</li><li>向 <span class="math inline">\(a\)</span> 中写入一个下标为 <spanclass="math inline">\(i\in T_I\)</span> 的元素. 令 <spanclass="math inline">\(e\in T_E\)</span> 表示要写入的值. 数组 <spanclass="math inline">\(a\)</span> 中元素 <spanclass="math inline">\(i\)</span> 被 <spanclass="math inline">\(e\)</span> 替换记为 <spanclass="math inline">\(a\{i\leftarrow e\}\)</span>.该运算符称作数组更新或者数组存储运算符.</li></ol><p>我们将用于推理索引和元素的理论分别称为索引理论(indextheory)和要素理论(element theory). 数组理论通过索引和元素理论进行参数化.通过递归地定义 <span class="math inline">\(T_A(n)\)</span> 就能得到<span class="math inline">\(n\)</span> 维数组. 对于 <spanclass="math inline">\(n \ge 2\)</span>, 我们只需将 <spanclass="math inline">\(T_A(n-1)\)</span> 添加到 <spanclass="math inline">\(T_A(n)\)</span> 的元素类型中去.</p><p>索引和元素理论的选择将影响所得数组理论的表达能力. 例如,索引理论需要允许存在和全称量词,以便对诸如"存在一个数组元素为零"或"该数组的所有元素都大于零"之类的属性进行建模.合适的索引理论的一个例子是Presburger算术(Presburger arithmetic),即具有量词的整数的线性演算.</p><h2 id="语法">1.1 语法</h2><p>我们将数组理论的语法定义为对索引理论和元素理论的组合的扩展. 令 <spanclass="math inline">\(term_I\)</span> 和 <spanclass="math inline">\(term_E\)</span> 分别表示这两个理论中的一项.先定义一个数组项 <span class="math inline">\(term_A\)</span>: <spanclass="math display">\[term_A:array-identifier\ |\ term_A\{ term_I\leftarrow term_E \}.\]</span> 然后将元素的项扩展至包含数组元素, 比如说, <spanclass="math display">\[term_E:term_A[term_I]\ |\ (previous\ rules),\]</span> 其中 <span class="math inline">\(previous\ rules\)</span>表示在此扩展之前定义 <span class="math inline">\(term_E\)</span>的语法规则. 最终, 我们通过允许数组项之间的等式来扩展公式中的谓词: <spanclass="math display">\[formula:term_A=term_A\ |\ (previous\ rules),\]</span> 其中 <span class="math inline">\(previous\ rules\)</span>表示在此扩展之前定义 <span class="math inline">\(formula\)</span>的语法规则. 如果索引理论包括量词,则在数组之间具有显式等式的语法的扩展是多余的, 因为对于数组 <spanclass="math inline">\(a_1\)</span> 和 <spanclass="math inline">\(a_2\)</span>,如果 <span class="math inline">\(a_1= a_2\)</span>, 那么该等式也可以写成 <span class="math inline">\(\foralli.a_1[i]=a_2[i]\)</span>.</p><h2 id="语义">1.2 语义</h2><p>我们用三个公理说明数组理论中新的原子和项的含义.</p><p>第一个公理给出了数组索引运算符的确切含义. 如果数组相同并且索引相同,则两个数组索引项的值相同. <span class="math display">\[\forall a_1\in T_A.\forall a_2\in T_A.\forall i\in T_I.\forall j\inT_I.(a_1=a_2\land i=j)\Longrightarrow a_1[i]=a_2[j].\tag{a.1}\]</span>用于定义数组更新运算符含义的公理是"读写公理"(<strong>read-over-writeaxiom</strong>): 数组值 <span class="math inline">\(e\)</span>在被写入下标为 <span class="math inline">\(i\)</span> 的数组 <spanclass="math inline">\(a\)</span> 中之后, 那么该数组索引为 <spanclass="math inline">\(i\)</span> 的值就为 <spanclass="math inline">\(e\)</span>. 数组中任意下标不为 <spanclass="math inline">\(i\)</span> 的值与写之前一致: <spanclass="math display">\[\forall a\in T_A.\forall e\in T_E.\forall i\in T_I.\forall j\in T_I.a\{i\leftarrow e\}[j]=\begin{equation}\left\{\begin{array}{lr}e&amp;:&amp;i=j\\a[j]&amp;:&amp;otherwise.\end{array}\right.\end{equation}\tag{a.2}\]</span> 最后, 我们用可扩展性规则(<strong>extensionalityrule</strong>)赋予数组相等的明显的含义: <span class="math display">\[\forall a_1\in T_A.\forall a_2 \in T_A.(\forall i\inT_I.a_1[i]=a_2[i])\Longrightarrow a_1=a_2.\tag{a.3}\]</span></p><h1 id="消除数组项">2. 消除数组项</h1><p>我们提出一种将数组理论中的公式转换为由索引理论和元素理论组成的公式的方法.如果这种组合的理论包含未解释函数和针对索引的量词, 该变换是可应用的.</p><p>考虑公理 <span class="math inline">\(a.1\)</span>,该公理定义了数组索引操作符的语义. 再考虑以下函数一致性. 非正式地,函数一致性要求同一个函数的两个应用, 如果它们的参数一样的话,那所得到的返回结果必须一致. 可以将公理 <spanclass="math inline">\(a.1\)</span> 看作是函数一致性的一种特例.</p><p>可以用一个未解释函数对数组索引操作符做替换. 有如下数组理论公式, 其中<span class="math inline">\(a\)</span> 是一个 <spanclass="math inline">\(\rm char\)</span> 类型的数组: <spanclass="math display">\[(i=j\land a[j]=&#39;z&#39;)\Longrightarrow a[i]=&#39;z&#39;.\]</span> 字符常量 <span class="math inline">\(&#39;z&#39;\)</span>是一个数组元素的成员. 令 <span class="math inline">\(F_a\)</span>代表为数组 <span class="math inline">\(a\)</span> 引入的未解释函数:<span class="math display">\[(i=j\land F_a(j)=&#39;z&#39;)\Longrightarrow F_a(i)=&#39;z&#39;.\]</span>上面的公式用针对等式和未解释函数的判定程序可以验证其有效性.</p><p>关于数组更新操作符.一种对数组更新操作进行建模的方法是用一个新的同类型的数组变量 <spanclass="math inline">\(a&#39;\)</span> 替换 <spanclass="math inline">\(a\{i\leftarrow e\}\)</span> 形式的每一个表达式.然后, 添加两个约束, 这些约束直接对应于可重写公理的两种情况:</p><ol type="1"><li><span class="math inline">\(a&#39;[i]=e\)</span> 为要写入的值,</li><li><span class="math inline">\(\forall j\ne i.a&#39;[j]=a[j]\)</span>为那些未改变的值.</li></ol><p>以上称之为写规则(<strong>write rule</strong>),是对数组理论公式的等价保留转换.</p><p>比如说, 公式 <span class="math display">\[a\{i\leftarrow e\}[i]\ge e \tag{2.1}\]</span> 就是通过引入一个新的数组标识符 <spanclass="math inline">\(a&#39;\)</span> 替换了 <spanclass="math inline">\(a\{i\leftarrow e\}\)</span> 转换过来的. 另外,添加约束 <span class="math inline">\(a&#39;[i]=e\)</span>, 就能得到<span class="math display">\[a&#39;[i]=e \Longrightarrow a&#39;[i]\ge e,\]</span> 上式子也显示了(2.1)的有效性.需要使用重写公理的第二部分来显示如下公式的有效性 <spanclass="math display">\[a[0]=10\Longrightarrow a\{1\leftarrow 20\}[0]=10.\]</span> 和以前一样, 通过用新的标识符 <spanclass="math inline">\(a&#39;\)</span> 替换 <spanclass="math inline">\(a\{ 1\leftarrow 20 \}\)</span>,并添加上述两个约束来对公式进行转换: <span class="math display">\[(a[0]=10\land a&#39;[1]=20\land (\forall j\ne1.a&#39;[j]=a[j]))\Longrightarrow a&#39;[0]=10.\]</span> 通过使用两个未解释函数 <spanclass="math inline">\(F_a\)</span> 和 <spanclass="math inline">\(F_b\)</span> 分别替换 <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(a&#39;\)</span> 得到: <spanclass="math display">\[(F_a(0)=10\land F_{a&#39;}(1)=20\land (\forall j\ne1.F_{a&#39;}(j)=F_a(j))\Longrightarrow F_{a&#39;}(0)=10.\]</span> 这个简单的例子表明, 只要索引理论提供了量词,数组理论就可以简化为索引理论和未解释函数的组合.问题在于这种组合不一定是可判定的.带有量词的便捷索引理论是Presburger演算, 实际上,它与未解释函数的组合是不可判定的.如上所述，即使索引理论和元素理论的组合是可判定的,数组理论也是不可判定的. 因此需要限制所考虑的公式集,以便得到一个判定程序. 这是归约算法使用的方法.</p><h1 id="the-reduction-algorithm">3. The Reduction Algorithm</h1><p>规约算法从数组理论的数组属性片段中接收一个公式,并将其简化为一个使用元素和索引理论与等式和未解释函数相结合的可满足公式.<span class="math display">\[\begin{aligned}&amp;\mathbf{Algorithm\ 1}:\ \text{ARRAY-REDUCTION}\\\\&amp;\mathbf{Input:}\ \text{An array property formula}\ \phi_A\ \text{inNNF}\\&amp;\mathbf{Output:}\quad \text{A formula }\phi_{UF}\ \text{in theindex and element theories with}\\&amp;\quad\quad\quad\quad\quad\; \text{uninterpretedted functions}\\\\&amp;1.\; \text{Apply the write rule to remove all array updates from}\phi_A.\\&amp;2.\; \text{Replace all existential quantifications of the form}\\exists i\in T_I.P(i)\ \text{by}\ P(j),\\&amp;\quad\;\text{where } j\ \text{is a fresh variable}.\\&amp;3.\; \text{Replace all universal quantifications of the form}\forall i\in T_I.P(i)\ \text{by }\\&amp;\hspace{73mm} \bigwedge_{i\in\mathcal{I}(\phi)} P(i).\\&amp;4.\; \text{Replace the array read operators by uninterpretedfunction and obtain}\\&amp;\quad \phi_{UF};\\&amp;5.\; \mathbf{return}\; \phi_{UF};\end{aligned}\]</span></p><p>上述算法将一个数组理论公式作为输入.将数组属性(也就是数组理论公式的标准型)转换为否定范式可能会将索引的全称量词转换为存在量词.由于句法上的限制, 公式不包含明显的量词替换. 算法第一步,应用写规则并移除所有的数组更新操作符. 所得到的公式包含针对索引的量词,数组读取操作, 基于元素和索引理论的子公式.</p><p>因为公式是否定范式形式的,所以存在量词可以用一个新的变量(也就是隐式地存在量化)进行替换. 全称量词<span class="math inline">\(\forall i\in T_I.P(i)\)</span> 用合取式<span class="math inline">\(\bigwedge_{i\in\mathcal{I}(\phi)}P(i)\)</span> 进行替换, 其中集合 <spanclass="math inline">\(\mathcal{I}(\phi)\)</span> 表示索引表达式, <spanclass="math inline">\(i\)</span> 就可能与公式 <spanclass="math inline">\(\phi\)</span> 等价. 该集合包含如下元素:</p><ol type="1"><li>在 <span class="math inline">\(\phi\)</span>中用作数组索引的所有表达式均不是量化变量.</li><li>在 <span class="math inline">\(\phi\)</span>中的数组索引表达式内使用的所有表达式都不是量化变量.</li><li>如果公式 <span class="math inline">\(\phi\)</span> 均不包含以上两项,为了获得一组非空的索引表达式, <spanclass="math inline">\(\mathcal{I}(\phi)\)</span> 就必须为 <spanclass="math inline">\(\{0\}\)</span>.</li></ol><p>最后, 数组读取操作符就用未解释函数进行了替换.</p><p>用一个例子说明规约算法的流程:</p><p>证明如下公式的有效性: <span class="math display">\[\begin{gather*}(\forall x\in \mathbb{N}_0.x\lt i\Longrightarrow a[x]=0) \\\land a&#39;=a\{i\leftarrow 0\}\\\Longrightarrow (\forall x\in \mathbb{N}_0.x\le i \Longrightarrowa&#39;[x]=0).\end{gather*}\]</span> 也就是说, 要说明以下公式的不可满足性: <spanclass="math display">\[\begin{gather*}(\forall x\in \mathbb{N}_0.x\lt i\Longrightarrow a[x]=0) \\\land a&#39;=a\{i\leftarrow 0\}\\\land(\exists x\in \mathbb{N}_0.x\le i \land a&#39;[x]\ne0).\end{gather*}\]</span> 应用写规则,得到 <span class="math display">\[\begin{gather*}(\forall x\in \mathbb{N}_0.x\lt i\Longrightarrow a[x]=0) \\\land a&#39;[i]=0\land \forall j\ne i.a&#39;[j]=a[j]\\\land (\exists x\in \mathbb{N}_0.x\le i \land a&#39;[x]\ne0).\end{gather*}\]</span> 算法的第二步, 用一个新变量 <span class="math inline">\(z\in\mathbb{N}_0\)</span> 实例化存在量词: <span class="math display">\[\begin{gather*}(\forall x\in \mathbb{N}_0.x\lt i\Longrightarrow a[x]=0) \\\land a&#39;[i]=0\land \forall j\ne i.a&#39;[j]=a[j]\\\land z\le i\land a&#39;[z]\ne0.\end{gather*}\]</span> 这个例子中的集合 <spanclass="math inline">\(\mathcal{I}\)</span> 为 <spanclass="math inline">\(\{i,z\}\)</span>. 所以替换两个全称量词: <spanclass="math display">\[\begin{gather*}(i\lt i\Longrightarrow a[i]=0)\land (z\lt i\Longrightarrow a[z]=0) \\\land a&#39;[i]=0\land (i\ne i\Longrightarrow a&#39;[i]=a[i])\land(z\nei\Longrightarrow a&#39;[z]=a[z])\\\land z\le i\land a&#39;[z]\ne0.\end{gather*}\]</span> 删除显然满足的合取式子: <span class="math display">\[\begin{gather*}(z\lt i\Longrightarrow a[z]=0) \\\land a&#39;[i]=0\land(z\ne i\Longrightarrow a&#39;[z]=a[z])\\\land z\le i\land a&#39;[z]\ne0.\end{gather*}\]</span> 然后分别用未解释函数 <span class="math inline">\(F_a\)</span>和 <span class="math inline">\(F_{a&#39;}\)</span> 替换两个数组 <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(a&#39;\)</span>: <span class="math display">\[\begin{gather*}(z\lt i\Longrightarrow F_a[z]=0) \\\land F_{a&#39;}[i]=0\land(z\ne i\Longrightarrow F_{a&#39;}[z]=F_a[z])\\\land z\le i\land F_{a&#39;}[z]\ne0.\end{gather*}\]</span> 通过区分 <span class="math inline">\(z\lt i\)</span>, <spanclass="math inline">\(z = i\)</span> 和 <span class="math inline">\(z\gti\)</span> 三种情况, 很容易看出该公式是不可满足的.</p>]]></content>
    
    
    <categories>
      
      <category>判定过程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>数组判定</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bit Vectors (2)</title>
    <link href="/2022/04/525f83ab9fb7/"/>
    <url>/2022/04/525f83ab9fb7/</url>
    
    <content type="html"><![CDATA[<h1 id="位向量演算">位向量演算</h1><h2 id="算术运算符">算术运算符</h2><p>算术运算符的约束通常依照那些作为电路的运算符的实现.实验说明了很多候选的电路设计往往是最简单的那种在验证的时候, SAT求解器的负担最小. 先定义一位加法器, 也就是全加器(full adder).</p><p><strong>全加器</strong>. 一个全加器使用两个函数来进行逻辑定义的,进位(carry)和求和(sum). 这两个函数都接收三个输入<spanclass="math inline">\(a,b,cin\)</span>. 函数carry计算加法器结果的进位,函数sum计算和: <span class="math display">\[\begin{aligned}sum(a,b,cin)&amp;\doteq (a\oplus b)\oplus cin,\\carry(a,b,cin)&amp;\doteq (a\land b)\lor ((a\oplus b)\land cin).\end{aligned}\]</span> 我们可以将该定义扩展到任意长度的位向量的加法器.</p><p>进位定义. 令 <span class="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 表示两个 <spanclass="math inline">\(l\)</span> 个比特长度的位向量, <spanclass="math inline">\(cin\)</span> 表示一个单比特位. 进位 <spanclass="math inline">\(c_0\)</span> 和 <spanclass="math inline">\(c_l\)</span> 递归地定义如下: <spanclass="math display">\[c_i \doteq\begin{equation}\left\{\begin{array}{lr}cin:i=0\\carry(x_{i-1},y_{i-1},c_{i-1}):otherwise.\end{array}\right.\end{equation}\]</span> <strong>加法器</strong>. 一个 <spanclass="math inline">\(l\)</span> 比特的加法器, 将两个 <spanclass="math inline">\(l\)</span> 比特的位向量 <spanclass="math inline">\(x,y\)</span> 和一个进位 <spanclass="math inline">\(cin\)</span> 映射为 对应的 和(sum) 与一个输出进位.令 <span class="math inline">\(c_i\)</span> 表示第 <spanclass="math inline">\(i\)</span> 个进位. 函数add用进位 <spanclass="math inline">\(c_i\)</span> 来定义: <span class="math display">\[\begin{aligned}add(x,y,cin)&amp;\doteq \langle result, cout\rangle,\\result_i &amp;\doteq sum(x_i,y_i,c_i)\ for\ i\in \{0,...,l-1\},\\cout &amp;\doteq c_n.\end{aligned}\]</span> 该结构的等效电路称作行波进位加法器(ripple carry adder).该加法器可以很容易地用一个带有进位 <spanclass="math inline">\(cin=0\)</span> 的加法器实现针对 <spanclass="math inline">\(t=a+b\)</span> 的约束: <spanclass="math display">\[\bigwedge_{i=0}^{l-1}(add(a,b,0).result_i\Longleftrightarrow e(t)_i).\]</span> 同时加法器可以通过归纳地证明上面的约束成立, 当且仅当 <spanclass="math inline">\(\langle a\rangle_U + \langle b\rangle_U = \langlee(t)\rangle_U\ \rm mod\ 2^l\)</span>,同时说明了约束与之前说明的语义相符.</p><p>通过使用以下约束, 在同一电路中实现减法 <spanclass="math inline">\(t=a-b\)</span>: <span class="math display">\[\bigwedge_{i=0}^{l-1}(add(a,\thicksim b,1).result_i \Longleftrightarrowe(t)_i).\]</span> 同样的, 该实现利用了事实: <span class="math inline">\(\langle(\thicksim b) + 1\rangle_S = -\langle b\rangle_S \rm\ mod\2^l\)</span>.</p><h2 id="关系运算符">关系运算符</h2><p>等式 <span class="math inline">\(a=_{l}b\)</span> 用简单的合取式实现:<span class="math display">\[\bigwedge_{i=1}^{l-1} a_i = b_i \Longleftrightarrow e(t).\]</span> 如上所述, 将 <span class="math inline">\(a\lt b\)</span>的大小关系转换为 <span class="math inline">\(a-b\lt 0\)</span>.并为减法建立加法器. 因此, <span class="math inline">\(b\)</span> 取反,加法器的进位设置为true. <span class="math inline">\(a\lt b\)</span>的结果取决于编码. 对于无符号操作数, 如果加法器的进位 <spanclass="math inline">\(cout\)</span> 为FALSE, 则 <spanclass="math inline">\(a\lt b\)</span> 成立: <spanclass="math display">\[\langle a\rangle_U \lt \langle b\rangle_U \Longleftrightarrow \negadd(a,\thicksim b,1).cout.\]</span> 如果是带符号的操作数, 当且仅当 <spanclass="math inline">\((a_{l-1}=b_{l-1})\ne cout\)</span> 时, <spanclass="math inline">\(a\lt b\)</span> 成立: <spanclass="math display">\[\langle a\rangle_S \lt \langle b\rangle_S \Longleftrightarrow(a_{l-1}\Longleftrightarrow b_{l-1})\oplus add(a,b,1).cout.\]</span> 涉及混合编码的比较是通过将两个操作数都扩展一位,然后进行带符号的比较来实现的.</p><h2 id="移位">移位</h2><p>我们称移位运算符的左侧操作数(要移位的向量)的宽度为移位的宽度(<em>widthof the shift</em>), 而右侧操作数的宽度为移位距离的宽度(<em>width of theshift distance</em>). 我们按照以下方式限制左右移位: 移位的宽度 <spanclass="math inline">\(l\)</span> 必须为2的幂次, 并且移位距离 <spanclass="math inline">\(n\)</span> 的宽度必须为 <spanclass="math inline">\(\log_2l\)</span>. 在这种限制下,可以通过使用以下称为桶形移位器(<em>barrelshifter</em>)的构造来实现左右移位. 该移位操作分为 <spanclass="math inline">\(n\)</span> 个阶段. 阶段 <spanclass="math inline">\(s\)</span> 可以将操作数移动 <spanclass="math inline">\(2^s\)</span> 个比特或者保持不动. 函数 <spanclass="math inline">\(ls\)</span> 针对阶段 <span class="math inline">\(s\in \{-1,...,n-1\}\)</span> 递归地定义如下: <spanclass="math display">\[ls(a_{[l]}, b_{[n]U},-1)\doteq a,ls(a_{[l]}, b_{[n]U}, s)\doteq \\\lambda i\in\{0,...,l-1\}.\begin{equation}\left\{\begin{array}{lr}(ls(a,b,s-1))_{i-2^s}&amp;:&amp;i\ge 2^s\land b_s\\(ls(a,b,s-1))_i&amp;:&amp;\neg b_s\\0&amp;:&amp;otherwise.\end{array}\right.\end{equation}\]</span> 桶形移位器地构造仅需要时间复杂度为 <spanclass="math inline">\(O(n\log n)\)</span> 的逻辑操作, 而原始的实现方式要<span class="math inline">\(O(n^2)\)</span> 时间复杂度.</p><h2 id="乘法和除法">乘法和除法</h2><p>乘法器可以按照最简单的电路设计来实现,它采用移位加法的思想(<em>shift-and-add idea</em>). 为阶段 <spanclass="math inline">\(s\in \{-1,...,n-1\}\)</span> 递归地定义函数<em>mul</em>, 其中 <span class="math inline">\(n\)</span>表示第二个操作数的宽度: <span class="math display">\[mul(a,b,-1)\doteq 0,\\mul(a,b,s)\doteq mul(a,b,s-1)+(b_s ? (a&lt;&lt;s):0).\]</span> 除法 <span class="math inline">\(a/_Ub\)</span>通过额外添加两个约束来实现: <span class="math display">\[\begin{aligned}&amp;b\ne 0\Longleftrightarrow e(t).b+r=a,\\&amp;b\ne 0\Longleftrightarrow r\lt b.\end{aligned}\]</span> 变量 <span class="math inline">\(r\)</span> 是一个新的位向量,其宽度与 <span class="math inline">\(b\)</span> 相同, 并包含余数.有符号除法和模运算以类似的方式实现.</p><h2 id="增量-bit-flattening-算法">增量 Bit Flattening 算法</h2><p>对于某些运算来说, BV-Constraint 生成的公式可能很大.除了这些公式的绝对大小之外, 它们的对称性和连通性也是最新的命题 SAT求解器的决策启发式方法的负担. 随之而来的后果就是,带乘法运算的公式通常很难求解.其他算术运算符(例如除法和模)也会有类似的结果.</p><p>比如说, 考虑如下位向量公式: <span class="math display">\[a\cdot b=c \land b\cdot a\ne c \land x\lt y \land x\gt y.\]</span> 当这个公式被编码成CNF时, 一个宽度为32位的 SAT实例就会产生约11000个变量. 该公式显然是不可满足的. 有两个原因:最开始的两个合取的式子矛盾, 同样地, 后两个合取的式子也是矛盾的. 大多数SAT 求解器的决策启发式方法倾向于首先对经常使用的变量进行拆分,因此倾向于对 <span class="math inline">\(a\)</span>, <spanclass="math inline">\(b\)</span>和 <spanclass="math inline">\(c\)</span> 进行判定. 因此,求解器试图在包括两个乘法运算的困难部分上显示该公式的不满足性.该公式仅包含两个关系运算符的"简单"部分被忽略了. 大多数命题 SAT求解器都不能在合理的时间内解决该公式.</p><p>因此, 在许多情况下, 逐步建立扁平化的公式 <spanclass="math inline">\(\mathcal{B}\)</span> 是有益处的.算法1是根据如下想法的实现: 正如之前, 从公式 <spanclass="math inline">\(\varphi\)</span> 的命题骨架开始. 然后,我们为"廉价"的运算符添加约束, 并为"昂贵"的运算符省略约束.按位运算符通常是廉价的, 而算术运算符很昂贵. 缺少约束的编码可以视为对公式<span class="math inline">\(\varphi\)</span> 的抽象. 那么,当前扁平化的公式 <span class="math inline">\(\mathcal{B}\)</span>会被传给一个命题 SAT 求解器. 如果, <spanclass="math inline">\(\mathcal{B}\)</span> 是不可满足的, 那么原公式<span class="math inline">\(\varphi\)</span> 也是不可满足的.将公式后半部分的约束条件添加到 <spanclass="math inline">\(\mathcal{B}\)</span> 中后,编码后的公式就变得不可满足, 并且会得出结论,在不考虑乘法运算的情况下原公式 <spanclass="math inline">\(\varphi\)</span> 是不可满足的.</p><p><span class="math display">\[\begin{aligned}&amp;\mathbf{Algorithm\ 1:\ }{\rmINCREMENTAL\mbox{-}BV\mbox{-}FLATTENING}\\&amp;\mathbf{Input:}\ {\rm A\ formula}\ \varphi\ {\rm in\bit\mbox{-}vector\ logic}\\&amp;\mathbf{Output:}\ {\rm &#39;&#39;Satisfiable&#39;&#39;\ if\ the\formula\ }\ {\rm is\ satisfiable,\ and\&#39;&#39;Unsatisfiable&#39;&#39;\ otherwise}\\\\&amp;1.\hspace{2mm}\mathbf{function}\ {\rmINCREMENTAL\mbox{-}BV\mbox{-}FLATTENING}(\varphi)\\&amp;2.\hspace{10mm} \mathcal{B}:=e(\varphi);\hspace{55mm}\triangleright\ {\rm propositional\ skeleton\ of\ }\varphi\\&amp;3.\hspace{10mm}\mathbf{for\ }{\rm each\ } t_{[l]}\in T(\varphi)\\mathbf{do} \\&amp;4.\hspace{18mm}\mathbf{for\ }{\rm each\ } i\in \{0,...,l-1\}\\mathbf{do} \\&amp;5.\hspace{26mm}{\rm set}\ e(t)_i\ {\rm to\ a\ new\ Boolean\variable};  \\&amp;6.\hspace{10mm}\mathbf{while\ } {\rm (TRUE)}\ \mathbf{do}\\&amp;7.\hspace{18mm}\alpha := {\rm SAT\mbox{-}SOLVER}(\mathcal{B}); \\&amp;8.\hspace{18mm}\mathbf{if\ }\alpha={\rm&#39;&#39;Unsatisfiable&#39;&#39;}\ \mathbf{return} \\&amp;9.\hspace{26mm}\mathbf{return}\ {\rm&#39;&#39;Unsatisfiable&#39;&#39;}; \\&amp;10.\hspace{16mm}\mathbf{else\ }\\&amp;11.\hspace{24mm}{\rm Let\ } I\subseteq T(\varphi)\ {\rm be\ the\set\ of\ terms\ that\ are}\\&amp;\hspace{38mm}{\rm inconsistent\ with\ the\ satisfying\ assignment};\\&amp;12.\hspace{24mm}\mathbf{if}\ I=\emptyset\ \mathbf{then} \\&amp;13.\hspace{30mm}\mathbf{return}\ {\rm&#39;&#39;Satisfiable&#39;&#39;};\\&amp;14.\hspace{24mm}\mathbf{else} \\&amp;15.\hspace{30mm}{\rm Select\ &#39;&#39;easy&#39;&#39;\ }F&#39;\subseteq I; \\&amp;16.\hspace{30mm}\mathbf{for}\ {\rm each\ } t_{[l]}\in F&#39;\\mathbf{do}\\&amp;17.\hspace{38mm}\mathcal{B}:=\mathcal{B}\ \wedge\ {\rmBV\mbox{-}CONSTRAINT}(e,t);\\\end{aligned}\]</span></p><p>如果公式 <span class="math inline">\(\mathcal{B}\)</span> 是可满足的,以下两种情况之一适用:</p><ol type="1"><li>原公式 <span class="math inline">\(\varphi\)</span> 是不可满足的,但是需要一个或多个被省略的约束条件说明这一点.</li><li>原公式 <span class="math inline">\(\varphi\)</span> 是可满足的.</li></ol><p>为了区分这两种情况, 我们可以检查 SAT求解器产生的可满足赋值是否满足省略的约束.由于我们可能已经移除了一些变量, 所以可能要对可满足的赋值进行扩展,将缺失的值设置为某个常数, 例如, 0. 如果此赋值满足所有约束,则第二种情况适用, 并且算法终止.</p><p>如果不是这样, 那么被省略的一个或多个约束条件与 SAT求解器提供的赋值不一致.我们用 <span class="math inline">\(I\)</span>来表示这些项的集合. 算法通过选择其中的一些项, 将其约束条件添加到公式<span class="math inline">\(\mathcal{B}\)</span> 中, 并重复进行.算法终止, 因为我们每一次迭代都会严格地添加更多的约束条件.在最坏的情况下, <span class="math inline">\(T(\varphi)\)</span>中的所有约束条件都被添加到编码中.</p><p>在许多情况下, 省略特定运算符的约束可能会导致扁平化的公式太弱,从而被太多的虚假模型所满足. 另一方面, 全约束可能会给 SAT求解器带来太多负担. 在全约束的最大强度和完全省略约束之间的折中办法,是用未解释的函数替换位向量上的函数.当在检查两个模型的等价性时,这种技术特别有效. 比如说, 令 <span class="math inline">\(a_1\ op\b_1\)</span> 和 <span class="math inline">\(a_2\ op\ b_2\)</span>为两项, 其中 <span class="math inline">\(op\)</span> 是二元运算符.用一个新的未解释的符号 <span class="math inline">\(G\)</span>来替换运算符 <span class="math inline">\(op\)</span> 得到 <spanclass="math inline">\(G(a_1,b_1)\)</span> 和 <spanclass="math inline">\(G(a_2,b_2)\)</span>. 得出的公式是抽象的,并不包含对应于 <span class="math inline">\(op\)</span>的扁平化的约束条件.</p>]]></content>
    
    
    <categories>
      
      <category>判定过程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据验证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bit Vectors (1)</title>
    <link href="/2022/03/7e9d080a4eac/"/>
    <url>/2022/03/7e9d080a4eac/</url>
    
    <content type="html"><![CDATA[<h1 id="位向量bit-vectors">位向量(Bit Vectors)</h1><h2 id="位向量演算">1 位向量演算</h2><p>计算机系统的设计是很容易出错的, 因此, 亟需验证此类系统的判定程序.一个计算机系统通过位向量(bit vectors)来对信息进行编码, 比如说, 数字.</p><p>位向量演算的文法: <span class="math display">\[\begin{aligned}formula&amp;:formula\land formula\ |\ \neg formula\ |\ (formula)\ |\atom\\atom&amp;:term\ rel\ term\ |\ Boolean-Identifier\ |\ term[constant]\\rel&amp;:&lt;\ |\ =\\term&amp;:term\ op\ term\ |\ identifier\ |\ ~term\ |\ constant\ |\ \\&amp;\ atom?term:term\ |\ term[constant:constant]\ |\ ext(term)\\op&amp;:+\ |\ -\ |\ \cdot\ |\ /\ |\ &lt;&lt;\ |\ &gt;&gt;\ |\ \&amp;\ |\|\ |\ \oplus\ |\ \circ\end{aligned}\]</span></p><p>通常来说, 其他运算符比如 <span class="math inline">\(\vee, \ne,\ge\)</span> 可以通过文法中的布尔运算符组合得到.其中一元运算符"~"表示按位取反(bitwise negation).<em>ext</em>函数代表符号扩展或者零扩展. 二元运算符"<spanclass="math inline">\(\circ\)</span>"表示位向量的串联.</p><p>为什么要使用位向量演算?</p><p>首先考虑如下公式: <span class="math display">\[(x-y\gt 0)\Longleftrightarrow (x&gt;y).\]</span> 如果 <span class="math inline">\(x,y\)</span>是有限宽度的位向量, 该等价形式就不再成立了,因为该减法操作可能存在溢出问题. 例如如下的的 C 程序片段:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> number = <span class="hljs-number">200</span>;<br>number = number + <span class="hljs-number">100</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sum: %d\n&quot;</span>, number);<br></code></pre></td></tr></table></figure><p>上述结果输出的是 44, 因为是运算是无符号的字符类型, 所以: <spanclass="math display">\[\begin{aligned}11001000=200\\+01100100=100\\\hline=00101100=44\end{aligned}\]</span> 在计算机中用 8 位二进制表示一个数的时候, 200 被存储为11001000. 当执行加 100 的操作时, 会造成溢出, 因为第九位被舍去了.</p><p>因此, 运算符, 比如"+", 的含义是通过模运算定义的. 但是,关于位向量的推理问题超出了溢出和模运算的范围. 出于效率原因,程序员使用位级运算符(bit-leveloperators)将尽可能多的信息编码为可用的位数.</p><p>比如说, 命题 SAT 求解器的实现. 命题 SAT 求解器在 CNF范式上的操作要存储大量的文字.我们假定已经对出现在公式中的文字进行了标号, <spanclass="math inline">\(x_1, x_2,...\)</span>.</p><p>针对 CNF 的 DIMACS 标准用符号数对文字进行编码, 例如, 文字 <spanclass="math inline">\(\neg x_3\)</span> 表示为 <spanclass="math inline">\(-3\)</span>. 治所用采用这种方式,是因为避免了额外用一位来存储位向量的符号位. 从另一个方面说,这种方法减少了变量数量可能增长至 <spanclass="math inline">\(2^{31}-1\)</span> 这种情况,而且对于实际应用还是能够满足的.</p><p>为了能够提取出变量的下标, 我们要对位向量的符号正负进行分析,如下程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">variable_index</span><span class="hljs-params">(<span class="hljs-keyword">int</span> literal)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(literal &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> -literal;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> literal;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于很难为现代处理器的分支预测机制进行预测, 因此在上述程序中实现<span class="math inline">\(if\)</span>语句所需的分支会减慢程序的执行速度. 因此, 大多数 SAT求解器使用不同的编码形式: 位向量的最低有效位用于编码文字的符号,其余位则用于编码变量. 然后可以通过位向量右移操作来提取变量的索引:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">variable_index</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> literal)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> literal &gt;&gt; <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似地, 符号位可以通过按位与操作取得:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">literal_sign</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> literal)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> literal &amp; <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述的右移和按位与操作, 在大多数微处理器中都有实现, 而且执行效率较高.这些位操作也高频地出现在硬件设计中.对这些设计和构造进行推理证明需要用到位向量演算.</p><h3 id="表示方法">1.1 表示方法</h3><p>我们使用 Church 的 <span class="math inline">\(\lambda\mbox{-}\rmnotation\)</span> 来定义向量. 一个有 <spanclass="math inline">\(l\)</span> 个比特位的位向量用 lambda 表达式描述:<span class="math display">\[\lambda.i\in\{0,...,l-1\}.f(i),\]</span> 其中 <span class="math inline">\(f(i)\)</span> 是表示第 <spanclass="math inline">\(i\)</span> 个比特的值的函数.</p><p>用一个例子说明 <span class="math inline">\(\lambda\mbox{-}\rmoperator\)</span> 是如何表示一个位向量的.</p><p>考虑如下表达式:</p><ul><li><p><span class="math display">\[  \lambda.i\in\{0,...,l-1\}.0  \]</span></p><p>表示 <span class="math inline">\(l\)</span> 长度的 0 向量.</p></li><li><p>一个 <span class="math inline">\(\lambda\)</span>表达式可以用另外一种方式来定义一个不具名的函数.我们可以定义一个函数<span class="math inline">\(z\)</span> <spanclass="math display">\[  z(i)\doteq 0,  \]</span> 对于函数<spanclass="math inline">\(z\)</span>也可以简单地写成 <spanclass="math inline">\(\lambda.i\in\{0,...,l-1\}.0\)</span>.</p></li><li><p>表达式 <span class="math display">\[  \lambda i\in\{0,...,7\}.  \begin{equation}  \left\{\begin{array}{lr}              0:i\ \rm is\ even\\              1:\rm otherwise          \end{array}  \right.  \end{equation}  \]</span> 表示位向量是 10101010.</p></li><li><p>表达式 <span class="math display">\[  \lambda i\in\{0,...,l-1\}.\neg x_i  \]</span> 表示对向量<spanclass="math inline">\(x\)</span>进行按位取反操作.</p></li></ul><h3 id="语义">1.2 语义</h3><p>首先给出位向量的定义. 一个位向量 <spanclass="math inline">\(b\)</span> 是一个给定长度 <spanclass="math inline">\(l\)</span> 或者维度的比特向量: <spanclass="math display">\[b:\{0,...,l-1\}\longrightarrow\{0,1\}.\]</span> 用 <span class="math inline">\(bvec_l\)</span> 来表示长度为<span class="math inline">\(l\)</span> 的所有 <spanclass="math inline">\(2^l\)</span> 个位向量的集合. 位向量 <spanclass="math inline">\(b\)</span> 的第 <spanclass="math inline">\(i\)</span> 个比特记为 <spanclass="math inline">\(b_i\)</span>.</p><p>一个位向量公式的含义依赖于位向量变量的宽度.即使不使用演算也是如此,比如说, <span class="math display">\[x\neq y\land x\neq z\land y\neq z\]</span> 对于其中三个如果只有一个比特的位向量来说是不可满足的,但是对于位数更多的是可满足的.</p><p>有时可以用位向量对正数进行编码(无符号位向量),也可以同时对正数和复数进行编码(有符号位向量). 因此,每一种表达式都有与之对应的类型(<strong>type</strong>).位向量的类型表述是</p><ol type="1"><li>表达式的宽度(以比特为单位),</li><li>无论是否有符号.</li></ol><p>我们将表示方式限制为具有固定长度的位向量,因为一旦允许任意宽度的位向量, 位向量演算就无法判定.宽度在实践中出现的大多数问题中都是已知的.</p><p><strong>按位运算符</strong></p><p>或运算符 "|". <span class="math inline">\(|_{[l]}: (bvec_l \timesbvec_l)\longrightarrow bvec_l\)</span>.</p><p>使用 <span class="math inline">\(\lambda\)</span> 表示符,按位或操作可以表示为: <span class="math display">\[a\ |\ b \doteq \lambda i.(a_i \lor b_i).\]</span> 其他的按位运算符的定义方式也是类似的.</p><p><strong>算术运算符</strong></p><p>具有算术运算符的位向量公式的含义取决于对其包含的位向量的解释.有许多使用位向量对数字进行编码的方法.最常用的整数编码是无符号整数的二进制编码(binaryencoding)和带符号整数的二进制补码(two's complement).</p><p>二进制编码(binary encoding). 令 <spanclass="math inline">\(x\)</span> 代表一个自然数, <spanclass="math inline">\(b\)</span> 是属于 <spanclass="math inline">\(bvec_l\)</span> 的一个位向量. 我们称 <spanclass="math inline">\(b\)</span> 为 <spanclass="math inline">\(x\)</span> 二进制编码, 当且仅当 <spanclass="math display">\[x = \langle b\rangle_U,\]</span> 其中的 <span class="math inline">\(\langle b\rangle_U\)</span> 有如下定义: <span class="math display">\[\langle \cdot \rangle_U: bvec_l \longrightarrow \{0,...,2^l-1\},\\\langle b\rangle_U \doteq \Sigma_{i=0}^{l-1}b_i\cdot 2^i.\]</span> <span class="math inline">\(b_0\)</span> 称为最低有效位, <spanclass="math inline">\(b_{l-1}\)</span> 称为最高有效位.</p><p>二进制编码只能用来表示非负整数. 同样地,一种编码复数的方式是使用其中一个比特位作为符号位.使用符号位的一种简单方法是在设置了指定位(例如最高有效位)的情况下简单地对数字进行取反.比如说, 1001 会被解释成 <span class="math inline">\(-1\)</span> 而不是1. 这种编码方式很少应用于实践中.大多数微处理器架构大多采用二进制补码进行编码.</p><p><strong>二进制补码(two's complement)</strong>. 令 <spanclass="math inline">\(x\)</span> 代表一个自然数, <spanclass="math inline">\(b\)</span> 是属于 <spanclass="math inline">\(bvec_l\)</span> 的一个位向量. 我们称 <spanclass="math inline">\(b\)</span> 为 <spanclass="math inline">\(x\)</span> 的二进制补码, 当且仅当 <spanclass="math display">\[x=\langle b \rangle_S,\]</span> 其中 <span class="math inline">\(\langle b \rangle\)</span>定义为: <span class="math display">\[\langle \cdot \rangle_S: bvec_l \longrightarrow\{-2^{l-1},...,2^{l-1}-1\},\\\langle b\rangle_S := -2^{l-1}\cdot b_{l-1}+ \Sigma_{i=0}^{l-2}b_i\cdot2^i.\]</span> 下标为 <span class="math inline">\(l-1\)</span> 的比特为位向量<span class="math inline">\(b\)</span> 的符号位.</p><p>比如说, 一些二进制整型和其对应的二进制补码编码 <spanclass="math display">\[\begin{aligned}&amp;\langle 11001000\rangle_U = 20,\\&amp;\langle 11001000\rangle_U=-128+64+8=-56,\\&amp;\langle 01100100\rangle_S=100.\end{aligned}\]</span> 如最开始的示例所描述的那样, 位向量的算术运算具有环绕效果:如果表示结果所需的位数超过了可用位数, 则结果的其他比特位将被丢弃,即结果被截断. 这对应于以 <span class="math inline">\(2^l\)</span>为底的取模运算. 写成 <span class="math inline">\(x=y\ mod\ b\)</span>代表 <span class="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span> 模 <spanclass="math inline">\(b\)</span> 是相等的.模运算的使用允许可以对所有的算数运算符进行直接定义:</p><ul><li><p>加法和减法: <span class="math display">\[  \begin{aligned}  a_{[l]} +_U b_{[l]} = c_{[l]} &amp;\Longleftrightarrow \langlea\rangle_U + \langle b\rangle_U = \langle c\rangle_U\ \rm mod\ 2^l,\\  a_{[l]} -_U b_{[l]} = c_{[l]} &amp;\Longleftrightarrow \langlea\rangle_U - \langle b\rangle_U = \langle c\rangle_U\ \rm mod\ 2^l,\\  a_{[l]} +_S b_{[l]} = c_{[l]} &amp;\Longleftrightarrow \langlea\rangle_S + \langle b\rangle_S = \langle c\rangle_S\ \rm mod\ 2^l,\\  a_{[l]} -_S b_{[l]} = c_{[l]} &amp;\Longleftrightarrow \langlea\rangle_S - \langle b\rangle_S = \langle c\rangle_S\ \rm mod\ 2^l.  \end{aligned}  \]</span></p></li><li><p>取反(unary minus): <span class="math display">\[  -a_{[l]}=b_{[l]}\Longleftrightarrow -\langle a\rangle_S = \langleb\rangle_S\ \rm mod\ 2^l.  \]</span></p></li><li><p>关系运算符(relational operators): <span class="math display">\[  \begin{aligned}  a_{[l]U}\lt b_{[l]U} &amp;\Longleftrightarrow \langle a\rangle_U \lt\langle b\rangle_U,\\  a_{[l]S}\lt b_{[l]S} &amp;\Longleftrightarrow \langle a\rangle_S \lt\langle b\rangle_S,\\  a_{[l]U}\lt b_{[l]S} &amp;\Longleftrightarrow \langle a\rangle_U \lt\langle b\rangle_S,\\  a_{[l]S}\lt b_{[l]U} &amp;\Longleftrightarrow \langle a\rangle_S \lt\langle b\rangle_U.  \end{aligned}  \]</span></p></li><li><p>乘法与除法: <span class="math display">\[  \begin{aligned}  a_{[l]}\cdot_U b_{[l]}=c_{[l]} &amp;\Longleftrightarrow \langlea\rangle_U\cdot \langle b\rangle_U = \langle c\rangle_U\ \rm mod\ 2^l,\\  a_{[l]}/_U b_{[l]}=c_{[l]} &amp;\Longleftrightarrow \langlea\rangle_U/ \langle b\rangle_U = \langle c\rangle_U\ \rm mod\ 2^l,\\  a_{[l]}\cdot_S b_{[l]}=c_{[l]} &amp;\Longleftrightarrow \langlea\rangle_U\cdot \langle b\rangle_S = \langle c\rangle_S\ \rm mod\ 2^l,\\  a_{[l]}/_S b_{[l]}=c_{[l]} &amp;\Longleftrightarrow \langlea\rangle_U/ \langle b\rangle_S = \langle c\rangle_S\ \rm mod\ 2^l.  \end{aligned}  \]</span> 乘法的语义无论参数是无符号数还是二进制补码形式都不受影响,因此下标 <span class="math inline">\(U/S\)</span> 可以省略.但是除法不行.</p></li><li><p>扩展运算符(extension operator):将原有的无符号位向量扩展为具有更多比特的无符号位向量称为零扩展(zeroextension), 对于有符号的位向量来说是符号扩展(sign extension). 令 <spanclass="math inline">\(l\le m\)</span>. 以下的扩展形式对值无影响: <spanclass="math display">\[  \begin{aligned}  ext_{[m]U}(a_{[l]}) = b_{[m]U} &amp;\Longleftrightarrow \langlea\rangle_U = \langle b\rangle_U,\\  ext_{[m]S}(a_{[l]}) = b_{[m]S} &amp;\Longleftrightarrow \langlea\rangle_S = \langle b\rangle_S.  \end{aligned}  \]</span></p></li><li><p>移位(shifting): 左移位运算符"&lt;&lt;"取两个操作数,并将第一个操作数向左移动第二个操作数相对应的位数.左侧操作数的宽度称为移位宽度(width of the shift),右侧操作数的宽度是移位距离的宽度(width of the shift distance),向量从右边开始用进行零填充: <span class="math display">\[  a_{[l]} &lt;&lt; b_U = \lambda i\in\{0,...,l-1\}.  \begin{equation}  \left\{\begin{array}{lr}              a_{i-\langle b\rangle_U}:i \ge \langle b\rangle_U\\              0:\rm otherwise.          \end{array}  \right.  \end{equation}  \]</span> 右移运算符的含义取决于第一个操作数的编码方式:如果使用的是二进制编码(也就是针对无符号位向量的编码),那就从左端开始填充0. 这称为<strong>逻辑右移(logical rightshift)</strong>: <span class="math display">\[  a_{[l]U} &gt;&gt; b_U = \lambda i\in\{0,...,l-1\}.  \begin{equation}  \left\{\begin{array}{lr}              a_{i+\langle b\rangle_U}:i \lt l - \langle b\rangle_U\\              0:\rm otherwise.          \end{array}  \right.  \end{equation}  \]</span>如果第一个操作数采用的是二进制补码进行编码(也就是针对有符号位向量的编码),那么<span class="math inline">\(a\)</span> 的符号位就要被复制.这称为<strong>算术右移(arithmetic right shift)</strong>: <spanclass="math display">\[  a_{[l]S} &gt;&gt; b_U = \lambda i\in\{0,...,l-1\}.  \begin{equation}  \left\{\begin{array}{lr}              a_{i+\langle b\rangle_U}:i \lt l - \langle b\rangle_U\\              a_{l-1}:\rm otherwise.          \end{array}  \right.  \end{equation}  \]</span></p></li></ul><h2 id="用flattening判定位向量的演算">2用Flattening判定位向量的演算</h2><p>最常用的针对位向量演算的判定程序称为 <em>flattening</em>.如图所示的算法实现了这一技术. 给定一个位向量演算公式 <spanclass="math inline">\(\varphi\)</span>, 该算法计算出一个等价的命题公式<span class="math inline">\(\mathcal{B}\)</span>,并将命题公式传给一个SAT求解器. <span class="math display">\[\begin{aligned}&amp;\mathbf{Algorithm\ 1.}\ \rm{BV\mbox{-}FLATTENING}\\&amp;\mathbf{Input:}\ \rm{A\ formula}\ \varphi\ {\rm in\bit\mbox{-}vector\ arithmetic}\\&amp;\mathbf{Output:}\ \rm{An\ equisatisfiable\ Boolean\ formula\ }\mathcal{B}\\&amp;\\&amp;1.\hspace{2mm}\mathbf{function\ } {\rm BV\mbox{-}FLATTENING}\\&amp;2.\hspace{10mm}\mathcal{B}:=e(\varphi);\hspace{50mm}\triangleright\{\rm the\ propositional\ skeleton\ of\ }\varphi\\&amp;3.\hspace{10mm} \mathbf{for\ } {\rm each}\ t_{[l]} \in T(\varphi)\\mathbf{do}\\&amp;4.\hspace{18mm} \mathbf{for\ } {\rm each}\ i\in \{0,...,l-1\}\\mathbf{do}\\&amp;5.\hspace{40mm} {\rm set}\ e(t)_i\ {\rm to\ a\ new\ Boolean\variable};\\&amp;6.\hspace{10mm} \mathbf{for\ } {\rm each\ } a\in At(\varphi)\\mathbf{do}\\&amp;7.\hspace{18mm} \mathcal{B}:=\mathcal{B}\wedge\ {\rmBV\mbox{-}CONSTRAINT}(e,a);\\&amp;8.\hspace{10mm} \mathbf{for\ } {\rm each\ } t_{[l]}\in T(\varphi)\\mathbf{do}\\&amp;9.\hspace{18mm} \mathcal{B}:=\mathcal{B}\wedge\ {\rmBV\mbox{-}CONSTRAINT}(e,t);\\&amp;10.\hspace{8mm} \mathbf{return\ } \mathcal{B};\end{aligned}\]</span> 令 <span class="math inline">\(At(\varphi)\)</span> 表示原公式<span class="math inline">\(\varphi\)</span> 中原子的集合. 第一步,算法将 <span class="math inline">\(\varphi\)</span>中的原子用新的布尔变量进行替换. 用 <spanclass="math inline">\(e(a)\)</span> 来表示替换之后的原子 <spanclass="math inline">\(a\)</span>, 并且 <span class="math inline">\(a\inAt(\varphi)\)</span>, 这个过程称为 <spanclass="math inline">\(a\)</span> 的命题编码器(propositional encoder).所有的原子被布尔变量替换之后形成的公式记为 <spanclass="math inline">\(e(\varphi)\)</span>, 称之为公式 <spanclass="math inline">\(\varphi\)</span> 的命题骨架(propositionalskeleton). 命题骨架是初始赋值给 <spanclass="math inline">\(\mathcal{B}\)</span> 的表达式. 令 <spanclass="math inline">\(T(\varphi)\)</span> 代表原公式 <spanclass="math inline">\(\varphi\)</span> 中项(terms)的集合. 算法对 <spanclass="math inline">\(T(\varphi)\)</span>中的每一个位向量的项都赋一个新的布尔变量的向量. 用 <spanclass="math inline">\(e(t)\)</span> 表示对于给定 <spanclass="math inline">\(t\)</span> 的变量向量, <spanclass="math inline">\(t \in T(\varphi)\)</span>, 用 <spanclass="math inline">\(e(t)_i\)</span> 表示 <spanclass="math inline">\(t\)</span> 中索引为 <spanclass="math inline">\(i\)</span> 的 变量. <spanclass="math inline">\(e(t)\)</span> 的宽度与项 <spanclass="math inline">\(t\)</span> 的宽度一致. 然后, 该算法在公式 <spanclass="math inline">\(\varphi\)</span> 上做迭代, 并计算相应的约束.约束由函数 BV-CONSTRAINT 返回, 并添加到公式 <spanclass="math inline">\(\mathcal{B}\)</span> 中.</p><p>特定原子 <span class="math inline">\(a\)</span> 或项 <spanclass="math inline">\(t\)</span> 所需的约束分别取决于原子或项.如果是位向量或布尔变量, 则不需要约束, 并且 BV-CONSTRAINT 返回真. 如果<span class="math inline">\(t\)</span> 是一个位向量约束 <spanclass="math inline">\(C_{[l]}\)</span>, 那么会生成以下约束: <spanclass="math display">\[\bigwedge_{i=1}^{l-1}(C_i \Longleftrightarrow e(t)_i).\]</span> 否则, 项 <span class="math inline">\(t\)</span>必须包含一个位向量运算符. 所需的约束依赖于这个运算符.按位运算符的约束很简单. 比如说, 考虑按位或, 令 <spanclass="math inline">\(t = a|_{[l]}b\)</span>. 函数 BV-CONSTRAINT返回的约束为 <span class="math display">\[\bigwedge_{i=0}^{l-1}((a_i\lor b_i)\Longleftrightarrow e(t)_i).\]</span> 其他的按位运算符对应的约束与上述的形式一致.</p><p>上述算法其实就是对一个位向量演算公式进行布尔变量变量编码和添加相应的布尔约束条件,进而传给SAT求解器, 并对公式进行可满足性的判定.</p>]]></content>
    
    
    <categories>
      
      <category>判定过程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据验证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性演算(二)</title>
    <link href="/2022/03/7ddb5ee9afcf/"/>
    <url>/2022/03/7ddb5ee9afcf/</url>
    
    <content type="html"><![CDATA[<h1 id="线性演算求解">线性演算求解</h1><h2 id="分支定界法the-branch-and-bound-method">1 分支定界法(The Branchand Bound Method)</h2><p>分支定界法主要用于解决<strong>整数</strong>线性规划问题(integerlinear programs). 就像 Simplex 算法的例子一样,分支定界法使用来解决优化问题的,但是我们还是讨论其在判定问题中的应用.</p><p><strong>定义</strong>:松弛系统(relaxed system)给定一个线性规划系统(integer linear system) <spanclass="math inline">\(S\)</span>, 该系统没有整数的要求, 也就是说,变量没有要求必须是整型.</p><p>用 relaxed(<span class="math inline">\(S\)</span>) 来表示系统 <spanclass="math inline">\(S\)</span> 的松弛问题. 假定存在一个程序 <spanclass="math inline">\(LP_{feasible}\)</span>,该程序接收一个线性规划系统作为输入, 如果 <spanclass="math inline">\(S\)</span> 是可满足的则返回"unsat",否则返回一组可满足的赋值. 可以通过通用 Simplex 算法的变式来实现 <spanclass="math inline">\(LP_{feasible}\)</span>. 如下算法,判定一个整型线性约束规划系统的可满足性问题. <spanclass="math display">\[\begin{aligned}&amp;\mathbf{Algorithm\ 1:\ }{\rmFEASIBILITY\mbox{-}BRANCH\mbox{-}AND\mbox{-}BOUND}\\&amp;\mathbf{Input:}\ {\rm An\ integer\ linear\ system}\ S\\&amp;\mathbf{Output:}\ {\rm &#39;&#39;Satisfiable&#39;&#39;\ if}\ S\{\rm is\ satisfiable,\ and\ &#39;&#39;Unsatisfiable&#39;&#39;\otherwise}\\\\&amp;1.\hspace{2mm}\mathbf{procedure}\ {\rmSEARCH\mbox{-}INTEGRAL\mbox{-}SOLUTION}(S) \\&amp;2.\hspace{10mm}{\rm res}=LP_{feasible}({\rm relaxed}(S)); \\&amp;3.\hspace{10mm}\mathbf{if\ }{\rm res\ =\&#39;&#39;Unsatisfiable&#39;&#39;}\ \mathbf{then\return};\hspace{30mm}\triangleright\ {\rm prune\ branch}\\&amp;4.\hspace{10mm}\mathbf{else\ }\\&amp;5.\hspace{18mm}\mathbf{if}\ {\rm res\ is\ integral\}\mathbf{then}\hspace{40mm}\triangleright\ {\rm integer\ solution\found}\\&amp;\hspace{30mm}\mathbf{abort\ }{\rm(&#39;&#39;Satisfiable&#39;&#39;)}; \\&amp;6.\hspace{18mm}\mathbf{else\ }\\&amp;7.\hspace{26mm} {\rm Select\ a\ variable\ }v{\rm\ that\ is\assigned\ a\ nonintegral\ value\ }r;\\&amp;8.\hspace{26mm} {\rm SEARCH\mbox{-}INTEGRAL\mbox{-}SOLUTION}(S\\cup\ (v\le\lfloor r\rfloor));\\&amp;9.\hspace{26mm} {\rm SEARCH\mbox{-}INTEGRAL\mbox{-}SOLUTION}(S\\cup\ (v\ge\lceil r\rceil));\\&amp;10.\hspace{78mm}\triangleright\ {\rm no\ integer\ solution\ in\this\ branch} \\\\\\\\&amp;11.\hspace{2mm}\mathbf{procedure}\ {\rmFEASIBILITY\mbox{-}BRANCH\mbox{-}AND\mbox{-}BOUND}(S) \\&amp;12.\hspace{8mm}{\rm SEARCH\mbox{-}INTEGRAL\mbox{-}SOLUTION}(S); \\&amp;13.\hspace{8mm}\mathbf{return\}{\rm(&#39;&#39;Unsatisfiable&#39;&#39;)};\\\end{aligned}\]</span> 该算法通过程序 <spanclass="math inline">\(LP_{feasible}\)</span> 来解决松弛问题;如果该问题是不可满足的, 那么就回溯, 因为在该分支下没有整数解. 相反,如果该问题是可满足的, 同时 <spanclass="math inline">\(LP_{feasible}\)</span> 返回了一组整数解,那么该问题终止. 否则, 该问题分解为两个子问题, 并递归调用自身.下面用个例子说明问题的分解是如果处理的.</p><h3 id="例1">例1</h3><p>设 <span class="math inline">\(x_1,...,x_4\)</span> 是系统 <spanclass="math inline">\(S\)</span> 的变量. 假定 <spanclass="math inline">\(LP_{feasible}\)</span> 返回一组解 <spanclass="math display">\[(1,0.7,2.5,3)\tag{1}\]</span> SEARCH-INTEGRAL-SOLUTION方法在变量 <spanclass="math inline">\(x_2\)</span> 和 <spanclass="math inline">\(x_3\)</span> 之间进行选择, <spanclass="math inline">\(x_2,x_3\)</span> 是非整数赋值的变量.假定选择了变量 <span class="math inline">\(x_2\)</span>. 在算法的第 8行, 然后, 将 <span class="math inline">\(S\)</span>(在当前递归层级求解的线性系统)增加约束, 并发送给更深的递归层级求解.<span class="math display">\[x_2\le0\tag{2}\]</span> 如果在当前分支下, 没有合适的解, 那么对系统 <spanclass="math inline">\(S\)</span> 将使用另外的约束条件,并同时进一步递归求解. <span class="math display">\[x_2\ge1\tag{3}\]</span> 如果这两次调用都返回了, 就说明 <spanclass="math inline">\(S\)</span> 没有可满足的解, 判定程序就回溯.应当注意, 从初始的递归层回溯,将会导致FEASIBILITY-BRANCH-AND-BOUND算法返回"Unsatisfiable",即不可满足.</p><p>上述算法存在一个问题, 该算法不是完备的(complete):会有让其一直分支下去的例子, 即进入递归的死循环. 比如说线性系统 <spanclass="math inline">\(1\le 3x-3y\le2\)</span>, 没有整数解,但是也没有有界实数解, 所以该系统会让算法一直循环下去. 为了算法的完备性,必须依靠这些公式具有的小模型属性. 也就是说, 如果存在可满足的解,那么在有限域(finite bound)中, 也应该存在这样的解, 对于该理论,这是可计算的. 因此, 一旦我们在每个变量的域上计算了此界限,就可以在传值之后停止搜索. 同样的界限同样可以应用于可行性问题. 简要地说,给定一个整数线性规划系统 <span class="math inline">\(S\)</span>, <spanclass="math inline">\(M\times N\)</span> 的系数矩阵 <spanclass="math inline">\(A\)</span>, 如果有一组解, 那么系统 <spanclass="math inline">\(S\)</span> 的凸包的极点也是一组解, 并且任一解<span class="math inline">\(x^0\)</span> 有如下约束: <spanclass="math display">\[x_j^0\le((M+N)\cdot N\cdot \theta)^N\ {\rm for}\ j = 1,...,N,\]</span> 其中, <span class="math inline">\(\theta\)</span>是该问题中的最大元素. 因此上式给定每一变量设定了界限,也就是给每一个变量添加了显式的约束, 强制算法终止.</p><p>其实,分支定界法可以直接扩展成一种解决一些变量是整型而其他的是实型的系统.在优化问题中, 这类问题就是混合线性规划问题(mixed integerprogramming).</p><h2 id="切平面cutting-planes">2 切平面(Cutting Planes)</h2><p>切平面是添加在线性系统中的约束, 用以移除非整数解;如果系统中的解所有都是可满足的整数解, 那么维持这种可满足性.这些新的约束提高了求解整数线性规划系统过程中松弛的紧密度,因此可以使分支定界算法运行得更快(这种组合称作分支剪界, branch-and-cut).此外, 如果满足某些条件, 以下所述类型的 Simplex和切平面算法将形成整数线性演算的判定过程.</p><p>我们讨论切平面的一类, 称作 Gomory 剪切(Gomory cuts). 先说明例子,然后推广.</p><h3 id="例2">例2</h3><p>假定问题包含整型变量 <spanclass="math inline">\(x_1,x_2,x_3\)</span>, 有下界 <spanclass="math inline">\(1\le x_1\)</span> 和 <spanclass="math inline">\(0.5\le x_2\)</span>. 此外, 假定通用 Simplex算法的最终的表(tableau)包含下面的约束 <span class="math display">\[x_3 = 0.5x_1+2.5x_2,\]</span> 并且有一组解 <spanclass="math inline">\(\alpha:\{x_3\mapsto1.75, x_1\mapsto1,x_2\mapsto0.5\}\)</span>, 显然, 该赋值是满足上面的式子的.每个变量减去该赋值得到 <span class="math display">\[x_3-1.75=0.5(x_1-1)+2.5(x_2-0.5).\]</span> 现在将上面式子改写成坐式是整数的形式: <spanclass="math display">\[x_3-1=0.75+0.5(x_1-1)+2.5(x_2-0.5).\]</span> 最右边的两项必须是正值, 因为 1 和 0.5 分别是 <spanclass="math inline">\(x_1\)</span> 和 <spanclass="math inline">\(x_2\)</span> 的下界. 因此,式子的右边累加起来也必须是一个整数, 也就是说 <spanclass="math display">\[0.75+0.5(x_1-1)+2.5(x_2-0.5)\ge1.\]</span> 但是, 该约束在赋值 <span class="math inline">\(\alpha\)</span>下是不可满足的, 因为通过构造, 除分数 0.75 外, 左侧的所有元素在 <spanclass="math inline">\(\alpha\)</span> 下均等于零. 也就是说,将此约束加入到松弛系统中将会把该解剔除掉. 从另一个角度来说,它不能移除任何整数解.</p><p>让我们将此示例概括为生成此类切割平面的方法. 泛化还涉及为变量分配上限,负系数和正系数的情况. 为了从约束中导出Gomory 剪切,该约束必须满足两个条件:首先, 对于基础变量的赋值要是分数; 其次,对于所有非基础变量的赋值要对应于它们其中一个有限域值.以下用例子说明,</p><p>考虑第 <span class="math inline">\(i\)</span> 个约束: <spanclass="math display">\[x_i=\Sigma_{x_j\in\mathcal{N}}a_{ij}x_j,\tag{4}\]</span> 其中 <span class="math inline">\(x_i\in \mathcal{B}\)</span>.令 <span class="math inline">\(\alpha\)</span> 是由通用 Simplex算法返回的赋值, 因此, <span class="math display">\[\alpha(x_i)=\Sigma_{x_j\in\mathcal{N}}a_{ij}\alpha(x_j).\tag{5}\]</span>现在将非基本变量划分为当前已分配其下限的变量和当前已分配其上限的变量两部分:<span class="math display">\[J=\{j\ |\  x_j\in\mathcal{N}\land \alpha(x_j)=l_j\},\\K=\{j\ |\  x_j\in\mathcal{N}\land \alpha(x_j)=u_j\}.\]</span> (4) 式子减 (5) 式子得 <span class="math display">\[x_i-\alpha(x_i)=\Sigma_{j\in J}a_{ij}(x_j-l_j)-\Sigma_{j\inK}a_{ij}(u_j-x_j).\tag{6}\]</span> 令 <spanclass="math inline">\(f_0=\alpha(x_i)-\lfloor\alpha(x_i)\rfloor\)</span>.因为我们假定 <span class="math inline">\(\alpha(x_i)\)</span> 不是整数,所以 <span class="math inline">\(0\lt f_0 \le1\)</span>. 可以将 (6)重写成 <span class="math display">\[x_i-\lfloor\alpha(x_i)\rfloor=f_0+\Sigma_{j\inJ}a_{ij}(x_j-l_j)-\Sigma_{j\in K}a_{ij}(u_j-x_j).\]</span> 注意等式左边是一个整数. 现在考虑两种情形.</p><ul><li><p>如果 <span class="math inline">\(\Sigma_{j\inJ}a_{ij}(x_j-l_j)-\Sigma_{j\in K}a_{ij}(u_j-x_j)\gt0\)</span>,又因等式左边要是整型, 所以, <span class="math display">\[  f_0+\Sigma_{j\in J}a_{ij}(x_j-l_j)-\Sigma_{j\inK}a_{ij}(u_j-x_j)\ge1.\tag{7}  \]</span> 现在将 <span class="math inline">\(J\)</span> 和 <spanclass="math inline">\(K\)</span> 分别分解成如下两个部分: <spanclass="math display">\[  \begin{aligned}  &amp;J^+=\{j\ |\ j\in J\land a_{ij}\gt0\},\\  &amp;J^-=\{j\ |\ j\in J\land a_{ij}\lt0\},\\  &amp;K^+=\{j\ |\ j\in K\land a_{ij}\gt0\},\\  &amp;K^-=\{j\ |\ j\in K\land a_{ij}\lt0\}.\\  \end{aligned}  \]</span> 仅收集 (7) 中不等式左边的正元素得 <spanclass="math display">\[  \Sigma_{j\in J^+}a_{ij}(x_j-l_j)-\Sigma_{j\inK^-}a_{ij}(u_j-x_j)\ge1-f_0,  \]</span> 或者, 等价地, <span class="math display">\[  \Sigma_{j\in J^+}\frac{a_{ij}}{1-f_0}(x_j-l_j)-\Sigma_{j\inK^-}\frac{a_{ij}}{1-f_0}(u_j-x_j)\ge1 \tag{8}  \]</span></p></li><li><p>如果 <span class="math inline">\(\Sigma_{j\inJ}a_{ij}(x_j-l_j)-\Sigma_{j\in K}a_{ij}(u_j-x_j)\le0\)</span>,又因等式左边要是整型, 所以, <span class="math display">\[  f_0+\Sigma_{j\in J}a_{ij}(x_j-l_j)-\Sigma_{j\inK}a_{ij}(u_j-x_j)\le0.\tag{9}  \]</span> 由式子 (9) 得出 <span class="math display">\[  \Sigma_{j\in J^-}a_{ij}(x_j-l_j)-\Sigma_{j\inK^+}a_{ij}(u_j-x_j)\le-f_0.  \]</span> 两边同除以 <span class="math inline">\(-f_0\)</span> 得<span class="math display">\[  -\Sigma_{j\in J^-}\frac{a_{ij}}{f_0}(x_j-l_j)+\Sigma_{j\inK^+}\frac{a_{ij}}{f_0}(u_j-x_j)\ge1.\tag{10}  \]</span></p></li></ul><p>注意式子 (8) 和 (10) 的左边都是大于 0 的, 因此这两个式子联立可以得到<span class="math display">\[\begin{aligned}&amp;\Sigma_{j\in J^+}\frac{a_{ij}}{1-f_0}(x_j-l_j)-\Sigma_{j\inJ^-}\frac{a_{ij}}{f_0}(x_j-l_j)\\&amp;+\Sigma_{j\in K^+}\frac{a_{ij}}{f_0}(u_j-x_j)-\Sigma_{j\inK^-}\frac{a_{ij}}{1-f_0}(u_j-x_j)\ge1\end{aligned}\]</span> 由于在当前赋值 <span class="math inline">\(\alpha\)</span> 下,左侧的每个元素都等于 0, 因此该赋值 <spanclass="math inline">\(\alpha\)</span> 被新的约束排除. 换句话说,可以保证对带有约束条件的线性问题的解与先前的解不同.</p><h2 id="fourier-motzkin-variable-elimination">3 Fourier-Motzkin VariableElimination</h2><p>与 Simplex 方法类似, Fourier-Motzkin变量消除接收<strong>实数</strong>变量线性约束的合取式, 并判定其可满足性.效率并不如 Simplex算法, 但是针对一些较小的公式还是有优势的. 在实践中,它主要用以消除存在量词.</p><p>让 <span class="math inline">\(m\)</span> 代表约束的数量, <spanclass="math inline">\(x_1,...,x_n\)</span> 表示这些约束所涉及到的变量.先从消除等式开始.</p><h3 id="等式约束的处理">3.1 等式约束的处理</h3><p>首先第一步, 如下形式的等式约束要被消除: <span class="math display">\[\Sigma_{j=1}^na_{i,j}\cdot x_j=b_i.\]</span> 我们在第 <span class="math inline">\(i\)</span> 个等式约束中,选择变量 <span class="math inline">\(x_j\)</span> 的非零系数 <spanclass="math inline">\(a_{i,j}\)</span>. 不失一般性地, 假定要消除的变量是<span class="math inline">\(x_n\)</span>. 上述约束可以改写成 <spanclass="math display">\[x_n=\frac{b_i}{a_{i,n}}-\Sigma_{j=1}^{n-1}\frac{a_{i,j}}{a_{i,n}}\cdotx_j.\tag{11}\]</span> 在其他所有的约束中, 将等式 (11) 右边将 <spanclass="math inline">\(x_n\)</span> 替换掉, 同时移除第 <spanclass="math inline">\(i\)</span> 个约束. 迭代这个过程,指导所有的等式都没移除掉. 这样系统中就只剩下不等式的形式了 <spanclass="math display">\[\bigwedge_{i=1}^m\Sigma_{j=1}^na_{i,j}x_j\le b_i.\]</span></p><h3 id="变量消除">3.2 变量消除</h3><p>变量消除的主要思想是, 启发式地选择一个变量,然后通过将其约束投影到系统的其余部分来消除它, 结果形成新的约束.</p><p>一个简单地例子来说明, 考虑如下约束 <span class="math display">\[0\le x\le 1, 0\le y\le 1, \frac{3}{4}\le z\le 1\]</span> 其约束如图1所示</p><p><img src="\img\lineararithmetic\fig1.png" style="zoom:50%;" /></p><center>图1</center><p>上述约束构造了一个长方体, 将这些约束投影到 <spanclass="math inline">\(x\)</span> 轴和 <spanclass="math inline">\(y\)</span> 轴, 由此就消除了变量 <spanclass="math inline">\(z\)</span>, 并形成了一个长方形. <spanclass="math display">\[0\le x\le 1, 0\le y\le 1.\]</span> 如图2所示,</p><p><img src="\img\lineararithmetic\fig2.png" style="zoom:50%;" /></p><center>图2</center><p>图2所示的三角形区域由下面的约束构造 <span class="math display">\[x\le y+10, y\le 15, y\ge -x+20.\]</span> 将该三角形投影到 <span class="math inline">\(x\)</span>轴就形成了一条线段 <span class="math display">\[5\le x\le 25.\]</span> 推广, 假定 <span class="math inline">\(x_n\)</span>是要被消除的变量. 约束根据x的系数进行划分. 考虑下标是<spanclass="math inline">\(i\)</span>的约束: <span class="math display">\[\Sigma_{j=1}^{n}a_{i,j}\cdot x_j\le b_i.\]</span> 拆分累加和, 可将上面的式子重写成 <span class="math display">\[a_{i,n}\cdot x_n \le b_i - \Sigma_{j=1}^{n-1}a_{i,j}\cdot x_j.\]</span> 如果 <span class="math inline">\(a_{i,n}\)</span> 为 0, 当消除<span class="math inline">\(x_n\)</span> 的时候可以忽略该约束. 否则,将上述不等式两边同除以 <span class="math inline">\(a_{i,n}\)</span>.如果 <span class="math inline">\(a_{i,n}\)</span>为正, 得到 <spanclass="math display">\[x_n \le\frac{b_i}{a_{i,n}}-\Sigma_{j=1}^{n-1}\frac{a_{i,j}}{a_{i,n}}\cdotx_j\tag{1}\]</span> 所以, 如果 <span class="math inline">\(a_{i,n}\gt 0\)</span>,该约束就是 <span class="math inline">\(x_n\)</span> 的上界. 如果 <spanclass="math inline">\(a_{i,n}\le 0\)</span>, 该约束就是下界.</p><h2 id="the-omega-test">4 The Omega Test</h2><p>Omega 测试算法是判定整型变量线性约束可满足问题的算法. 可以看作是Fourier-Motzkin 算法的变式. 这两者都不算是最快的判定过程,但是它们都可以用作存在量词的消除.</p><p>每一个合取式可以看作是如下形式的等式或者非严格等式 <spanclass="math display">\[\Sigma_{i=1}^na_ix_i=b,\\\Sigma_{i=1}^na_ix_i\le b.\]</span> 系数 <span class="math inline">\(a_i\)</span> 假定为整数;如果不是, 则可以通过使用系数合理的假设, 将约束条件乘以分母的最小公倍数,将问题转换为整数系数. Omega 测试算法的执行时间取决于系数 <spanclass="math inline">\(a_i\)</span> 的大小. 因此要将约束进行转换,以获得较小的系数. 这可以通过将每个约束的系数 <spanclass="math inline">\(a_1,a_2,...,a_n\)</span> 除以它们的最大公约数<span class="math inline">\(g\)</span> 来完成.所得的约束称为正则化(normalized)约束. 如果该约束为等式约束, 则得到 <spanclass="math display">\[\Sigma_{i=1}^n\frac{a_i}{g}x_i=\frac{b}{g}.\]</span> 如果 <span class="math inline">\(g\)</span> 不能整除 <spanclass="math inline">\(b\)</span>, 则该系统是不可满足的.如果该约束是一个不等式, 可以通过舍入常量来增强约束: <spanclass="math display">\[\Sigma_{i=1}^n\frac{a_i}{g}x_i\le \lfloor\frac{b}{g}\rfloor.\]</span> 比如说, 等式 <span class="math inline">\(3x+3y=2\)</span>可以正则化成 <span class="math inline">\(x+y=\frac{2}{3}\)</span>,由此是不可满足的. 约束 <span class="math inline">\(8x+6y\le 0\)</span>可以正则化为 <span class="math inline">\(4x+3y\le 0\)</span>. 约束 <spanclass="math inline">\(1\le 4y\)</span> 可以增强为 <spanclass="math inline">\(1\le y\)</span>.</p><p>在 Fourier-Motzkin 算法中, 等式形式和不等式形式的约束是分开考虑的;在对不等式约束进行处理之前, 所有的等式约束是被移除了的.</p>]]></content>
    
    
    <categories>
      
      <category>判定过程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>量词消除</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Small-step 操作语义</title>
    <link href="/2022/03/0d3f0f950b1e/"/>
    <url>/2022/03/0d3f0f950b1e/</url>
    
    <content type="html"><![CDATA[<h1 id="small-step-operational-semantics">Small-step OperationalSemantics</h1><h2 id="简介">1. 简介</h2><p>程序所要表达的"意思"是什么? 当我们写程序的时候,用不同种类的字符按照特定的顺序编成代码.但是以某种特定语法(syntax)形式所构成的仅仅是程序自身而已,并不能说明程序所包含的意义.</p><p>或许在程序执行的时候, 我们可以用解释器去定义一段程序的意思.但是解释器或者编译器中不可避免地会有bug,也就是说解释器或者编译器并不能准确地反映出程序的意义. 所以,必须要找到能够表达程序意思的方法.</p><p>这个方法就是, 要给出语言语义的形式化的数学定义.形式化的定义主要有如下几个好处:</p><ul><li><strong>较少歧义</strong>. 语言的行为的明晰的,这对那些需要用该语言编程的人员是有用的,为该语言实现一个编译器或者解释器, 或者为语言添加新的特性等等.</li><li><strong>更加精确</strong>.数学形式的概念和符号能够精确且准确地描述一种语言,并且说明合法程序中的一些限制.</li><li><strong>形式化论证</strong>.形式化的语义允许我们说明和证明需求的程序性质.</li></ul><p>但是, 形式化的语义可能导致复杂的数学模型,尤其当尝试对一个具有复杂特性的编程语言的所有细节进行描述时.现实世界中的编程语言很少有形式化的语义描述, 因为编程语言很复杂,有很多的特性, 难度很大. 为了能够描述这些语言特性,用于建模的数学公式或者符号必定非常复杂且难以理解. 那么,就需要重新设计一套基于数学符号的能够精确对语言特性进行建模的形式化规范.那么,在学术和应用研究中通常使用三种方法对编程语言的语义进行形式化的描述:</p><ul><li><p><strong>操作语义(operational semantics)</strong>:描述程序在一个抽象机器上是如何执行的.</p></li><li><p><strong>指称语义(denotational semantics)</strong>:讲程序建模为数学上的函数形式.</p></li><li><p><strong>公理语义(axiomatic semantics)</strong>:以逻辑表达式的形式对满足程序执行前后的行为进行定义.</p></li></ul><p>以上三种方法在不同的应用场景都有各自的优缺点.感兴趣的读者可以阅读综述文章<ahref="http://www.jos.org.cn/html/2019/1/5652.htm">形式化方法概貌</a>.</p><h2 id="简易语言的算术表达式">2. 简易语言的算术表达式</h2><p>为了介绍操作语义, 先设计一个简单的语言,基于该语言能够实现基本的算术运算.使用下列域(domain)来描述该语言的结构:</p><p><span class="math display">\[\begin{aligned}x,y,z   &amp;\in \mathbf{Var}\\n,m     &amp;\in \mathbf{Int}\\e       &amp;\in \mathbf{Exp}\end{aligned}\]</span></p><p>其中, <span class="math inline">\(\mathbf{Var}\)</span>是变量<strong>名</strong>的集合(例如, foo, bar). <spanclass="math inline">\(\mathbf{Int}\)</span> 是整型常量的集合(例如, 42).<span class="math inline">\(\mathbf{Exp}\)</span> 是表达式所在域,这里我们使用 BNF 范式对表达式进行语法的定义:</p><p><span class="math display">\[e::=x\ |\ n\ |\ e_1+e_2\ |\ e_1\times e_2\ |\ x:=e_1;e_2\]</span></p><p>表达式 <span class="math inline">\(x:=e_1;e_2\)</span> 说明变量 <spanclass="math inline">\(x\)</span> 先赋值为 <spanclass="math inline">\(e_1\)</span>, 后被赋值为 <spanclass="math inline">\(e_2\)</span>,范式中其他各项的含义不再做详细说明.</p><p>上述的语法为语言指定了格式. 但是存在歧义. 比如表达式 <spanclass="math inline">\(1+2\times 3\)</span>,根据语法可以构造出两个不同的抽象语法树(abstract syntax tree).</p><p><img src="\img\operseman\ast.svg" style="zoom:50%"/></p><p>有很多中方法解决存在的歧义问题. 其一, 重写语法规则,这样会使得语法变得复杂, 且难以理解. 其二, 加括号.</p><p><span class="math display">\[x\ |\ n\ |\ (e_1+e_2)\ |\ (e_1\times e_2)\ |\ x:=e_1;e_2\]</span></p><p>然而, 这也导致了不必要的混乱和复杂. 相反,我们把语言的"具体语法"(它规定了如何无歧义地将字符串解析为程序片段)与语言的"抽象语法"(它描述了程序片段的结构,可能是有歧义的)分开. 后续阐述中, 将使用抽象语法,并假定抽象语法树是已知的. 在编写表达式时,我们偶尔会使用括号来表示抽象语法树的结构,但小括号不是语言本身的一部分.</p><h2 id="小步操作语义">3. 小步操作语义</h2><p><code>操作语义 operational semantics</code>描述了程序是如何在抽象机器上执行的.<code>小步 small-step 操作语义</code>细化了这种执行,将其转变为表达式的连续规约(reduction),直到得到一个数值(对应上文中的语言), 该数值表示计算的结果.</p><p>抽象机器(abstractmachine)的状态通常称为<code>配置 configuration</code>(在程序逻辑的理论研究中,经常会遇到这个单词), 那么对于本文所述的语言就肯定包含两条信息:</p><ul><li><strong>store</strong> 也叫环境 environment 或者状态 state,<code>store</code> 所做的是将整型的数值赋给变量. 在程序的执行过程中,通常使用 <code>store</code> 去决定与变量的数值大小, 同时也可以对<code>store</code>进行更新来<strong>反映</strong>有一个新的数值赋给了变量.</li><li><strong>表达式左式的赋值</strong>.</li></ul><div class="note note-success">            <p>这里的 <code>store</code> 与计算机系统中的 store 概念类似,都有"存储"之意, 保存或者<strong>说明</strong>当前程序的状态.文中涉及较多术语, 作者认为不作硬性翻译为好.</p>          </div><p>由此, <code>stores</code> 的域就是从 <spanclass="math inline">\(\mathbf{Var}\)</span> 到 <spanclass="math inline">\(\mathbf{Int}\)</span> 的函数形式(映射 map, <spanclass="math inline">\(\mathbf{Var}\to \mathbf{Int}\)</span>),configuration 的域是 表达式和 <code>stores</code> 的二元组.</p><p><span class="math display">\[\begin{aligned}\mathbf{Config}&amp;=\mathbf{Exp}\times\mathbf{Store}\\\mathbf{Store}&amp;=\mathbf{Var}\to\mathbf{Int}\end{aligned}\]</span></p><p>在形式上, 使用一组方括号来表示 configurations. 例如, <spanclass="math inline">\(\langle(foo+2)\times(bar+1),\sigma\rangle\)</span>,这里的 <span class="math inline">\(\sigma\)</span> 就是一个 store,前者是一个包含了两个变量的表达式.</p><p>本文语言的小步操作语义就是一种关系 <spanclass="math inline">\(\rightarrow \subset\mathbf{Config}\times\mathbf{Config}\)</span>,该关系描述了一种配置是如何迁移(transition)到另一种配置的. 即, 关系 <spanclass="math inline">\(\rightarrow\)</span>说明了是如何一步一步地对程序的状态进行判定的.我们用中缀的形式表示这种关系. 给定任意两个configurations <spanclass="math inline">\(\langle e_1,\sigma_1\rangle\)</span> 与 <spanclass="math inline">\(\langle e_2,\sigma_2\rangle\)</span>,如何二者存在关系 <span class="math inline">\(\rightarrow\)</span>, 则<span class="math inline">\(\langle e_1,\sigma_1\rangle\rightarrow\langle e_2,\sigma_2\rangle\)</span>.</p><p>现在, 语言语义的定义就转变为对关系 <spanclass="math inline">\(\rightarrow\)</span> 的定义,该关系说明了抽象机配置之间的迁移.</p><p>这里存在一个问题, 整型域是无限的, 表达式的域也是无限的. 因此,可能的抽象机配置也是一个未知数, 可能的每一步的迁移状态也是一个未知数.所以, 我们要用有限的描述去表达迁移状态的无限集合.</p><p>我们可以使用推理规则来描述迁移函数:</p><p><span class="math display">\[\begin{aligned}&amp;{\rm VAR} \frac{}{\langle x,\sigma\rangle\rightarrow\langlen,\sigma\rangle}{\rm where}\ n=\sigma(x)\\\\&amp;{\rm LADD} \frac{\langle e_1,\sigma\rangle\rightarrow\langlee_1^\prime,\sigma^\prime\rangle}{\langle e_1+e_2,\sigma\rangle\rightarrow\langlee_1^\prime+e_2,\sigma^\prime\rangle}\hspace{6mm}{\rm RADD} \frac{\langle e_2,\sigma\rangle\rightarrow\langlee_2^\prime,\sigma^\prime\rangle}{\langle n+e_2,\sigma\rangle\rightarrow\langlen+e_2^\prime,\sigma^\prime\rangle}\\\\&amp;{\rm ADD} \frac{}{\langle n+m,\sigma\rangle\rightarrow\langlep,\sigma\rangle}{\rm where}\ p {\rm is\ the\ sum\ of\ }n\ {\rm and\ }m\\\\&amp;{\rm LMUL} \frac{\langle e_1,\sigma\rangle\rightarrow\langlee_1^\prime,\sigma^\prime\rangle}{\langle e_1\times e_2,\sigma\rangle\rightarrow\langle e_1^\prime\timese_2,\sigma^\prime\rangle}\hspace{6mm}{\rm RMUL} \frac{\langle e_2,\sigma\rangle\rightarrow\langlee_2^\prime,\sigma^\prime\rangle}{\langle n\times e_2,\sigma\rangle\rightarrow\langle n\timese_2^\prime,\sigma^\prime\rangle}\\\\&amp;{\rm MUL} \frac{}{\langle n\times m,\sigma\rangle\rightarrow\langlep,\sigma\rangle}{\rm where}\ p {\rm is\ the\ product\ of\ }n\ {\rm and\}m\\\\&amp;{\rm ASG1} \frac{\langle e_1,\sigma\rangle\rightarrow\langlee_1^\prime,\sigma^\prime\rangle}{\langle x:=e_1;e_2,\sigma\rangle\rightarrow\langlex:=e_1^\prime;e_2,\sigma^\prime\rangle}\hspace{6mm}{\rm ASG} \frac{}{\langle x:=n;e_2,\sigma\rangle\rightarrow\langle e_2,\sigma[x\mapston]\rangle}\end{aligned}\]</span></p><p>所谓推理规则, 直线上方公式和附加条件都成立的话,直线下方的事实也是成立的. 线上称为前提, 线下称为结论.没有前提的推理规则为公理, 有前提的即为推导规则.</p><p>同时, 我们使用标记 <span class="math inline">\(\sigma[x\mapston]\)</span> 表示一个 store 将变量 <span class="math inline">\(x\)</span>映射(map)到 一个整型 <span class="math inline">\(n\)</span>.更形式化和准确的表达是, 如果 <span class="math inline">\(f\)</span>是函数 <span class="math inline">\(\sigma[x\mapsto n]\)</span>,那么有:</p><p><span class="math display">\[\begin{equation}f(y)=\left\{\begin{aligned}&amp;n &amp; {\rm if}\ y=x\\&amp;\sigma(y) &amp; {\rm otherwise}\end{aligned}\right.\end{equation}\]</span></p><h2 id="应用语义规则">4. 应用语义规则</h2><p>基于第3节的语义推理规则, 我们尝试判定表达式 <spanclass="math inline">\((foo+2)\times(bar+1)\)</span> 的值, 其中 <spanclass="math inline">\(\sigma(foo)=4,\ \sigma(bar)=3\)</span>. 也就是说,我们要为配置: <span class="math inline">\(\langle(foo+2)\times(bar+1),\sigma\rangle\)</span>找到状态迁移的推导树(derivation tree).可以逐步的运用第3节的语义规则进行推理.</p><p>根据表达式的形式, 我们应用语义规则 <code>LMUL</code> 来进行推理, 其中<span class="math inline">\(e_1=foo+2\)</span>, <spanclass="math inline">\(e_2=bar+1\)</span>, <spanclass="math inline">\(e_1^\prime\)</span> 暂且未知.</p><p><span class="math display">\[{\rm LMUL}\frac{\langle foo+2,\sigma\rangle\rightarrow\langlee_1^\prime,\sigma\rangle}{\langle (foo+2)\times(bar+1),\sigma\rangle\rightarrow\langlee_1^\prime\times(bar+1),\sigma\rangle}\]</span></p><p>接下来, 我们需要确定 <span class="math inline">\(e_1^\prime\)</span>的值. 从推理规则中找到符合 <span class="math inline">\(\langlefoo+2,\sigma\rangle\rightarrow \langle e_1^\prime,\sigma\rangle\)</span>结论的形式. 那么, 接下就应用 <code>LADD</code> 规则.</p><p><span class="math display">\[{\rm LADD} \frac{\langle foo,\sigma\rangle\rightarrow\langlee_1^{\prime\prime},\sigma\rangle}{\langle foo+2,\sigma\rangle\rightarrow\langlee_1^{\prime\prime}+2,\sigma\rangle}\]</span></p><p>其中, <span class="math inline">\(e_1^\prime = e_1^{\prime\prime} +2\)</span>. 然后, 重复这个过程, 对 <span class="math inline">\(\langlefoo,\sigma\rangle\rightarrow\langlee_1^{\prime\prime},\sigma\rangle\)</span> 进行推理, 应用公理<code>VAR</code>.</p><p><span class="math display">\[{\rm VAR} \frac{}{\langle foo,\sigma\rangle\rightarrow\langle4,\sigma\rangle}\]</span></p><p>因为有 <span class="math inline">\(\sigma(foo)=4\)</span>,所以应用公理, 证明结束. <spanclass="math inline">\(e^{\prime\prime}=4\)</span> 并且 <spanclass="math inline">\(e_1^\prime=4+2\)</span>. 由此, 可以构建推导树.</p><p><span class="math display">\[\begin{aligned}&amp;{\rm VAR}\frac{}{\langle foo,\sigma\rangle\rightarrow\langle 4,\sigma\rangle}\\&amp;{\rm LADD}\frac{}{\langle foo+2,\sigma\rangle\rightarrow\langle 4+2,\sigma\rangle}\\&amp;{\rm LMUL}\frac{}{\langle (foo+2)\times(bar+1),\sigma\rangle\rightarrow\langle(4+2)\times(bar+1),\sigma\rangle}\end{aligned}\]</span></p><p>基于语义规则, 上述推理证明了一步迁移: <spanclass="math inline">\(\langle(foo+2)\times(bar+1),\sigma\rangle\rightarrow\langle(4+2)\times(bar+1),\sigma\rangle\)</span> 在抽象机上是可行的.需要注意的是, 证明或者推导树必须是有穷的,也就是在有限步的计算之后是有结果的, 而且结论是有效的.接下去的推理步骤在此就省略了.</p><p>如果我们继续这个推理过程, 就能得到一个具体的计算结果.</p><p><span class="math display">\[\begin{aligned}\langle (foo+2)\times(bar+1),\sigma\rangle&amp;\longrightarrow\langle(4+2)\times(bar+1),\sigma\rangle\\&amp;\longrightarrow\langle 6\times(bar+1),\sigma\rangle\\&amp;\longrightarrow\langle 6\times(3+1),\sigma\rangle\\&amp;\longrightarrow\langle 6\times 4,\sigma\rangle\\&amp;\longrightarrow\langle 24,\sigma\rangle\end{aligned}\]</span></p><p><span class="math inline">\(\langle 24,\sigma\rangle\)</span>就成为最终配置. 对于简易语言的表达式来说, 最终配置的形式就是 <spanclass="math inline">\(\langle n,\sigma\rangle\)</span>, <spanclass="math inline">\(n\)</span> 是一个整数, <spanclass="math inline">\(\sigma\)</span> 是 store.</p><p>那么, 关系 <span class="math inline">\(\rightarrow^*\)</span> 是关系<span class="math inline">\(\rightarrow\)</span>的自反传递闭包(reflexive transitive closure). 即, 如果 <spanclass="math inline">\(\langle e,\sigma\rangle\rightarrow^*\langlee^\prime,\sigma^\prime\rangle\)</span>, 那么经过 0或者多次的推导(有限次), 最终能够得到从配置 <spanclass="math inline">\(\langle e,\sigma\rangle\)</span> 到 <spanclass="math inline">\(\langle e^\prime,\sigma^\prime\rangle\)</span>的迁移. 这时候, 我们可以记</p><p><span class="math display">\[\langle (foo+2)\times(bar+1),\sigma\rangle\longrightarrow^*\langle24,\sigma\rangle.\]</span></p>]]></content>
    
    
    <categories>
      
      <category>逻辑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语义</tag>
      
      <tag>推理规则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性演算(一)</title>
    <link href="/2022/02/39dd3a3dcdf6/"/>
    <url>/2022/02/39dd3a3dcdf6/</url>
    
    <content type="html"><![CDATA[<h1 id="线性演算linear-arithmetic">线性演算(Linear Arithmetic)</h1><p>线性演算文法定义: <span class="math display">\[\begin{aligned}formula&amp;:formula\land formula\ |\ (formula)\ |\ atom\\atom&amp;:sum\ op\ sum\\op&amp;:=\ |\ \le\ |\ &lt; \\sum&amp;:term\ |\ sum+term\\term&amp;:identifier\ |\ constant\ |\ constant\ identifier\end{aligned}\]</span> 根据文法构造良定义的线性演算公式, 如下: <spanclass="math display">\[3x_1+2x_2\le5x_3\ \land\ 2x_1-2x_2=0.\]</span> 从上面的公式可以看出, 等式逻辑(equalitylogic)是作为线性演算的一部分的.</p><h2 id="线性演算的求解器">1 线性演算的求解器</h2><p>Simplex 方法是针对数值优化的一个算法.给定实数变量的线性约束的合取公式, Simplex 算法用以找到目标函数的最佳值.目标函数和约束合称为线性程序(Linear program).我们只关注判定问题而不是优化问题, 所以, 讨论对于 Simplex 方法的一种变体,称作通用 Simplex 方法(general Simplex). 通用 Simplex方法接收在实数集上的线性约束的合取公式, 并且没有目标函数,并判定集合的可满足性质.另外, 整型线性规划(Integer linear programming,ILP)也是一类基于整型的约束问题.</p><h2 id="simplex-算法">2 Simplex 算法</h2><p>Simplex 算法, 判定弱线性不等式合取公式(weak linearinequalities)的可满足行问题.就公式的变量而言,约束集常伴有一个线性目标函数. 如果约束集合是可满足的, Simplex算法就提供一个可满足的赋值, 该赋值使得目标函数的值最大化. Simplex算法是最坏指数复杂度的算法. 也有多项式时间的算法解决此类问题(ellipsoidmethod, 1979). Simplex算法在实践中仍然是一个值得考虑的非常高效并广泛使用的方法,显然是因为现实中指数复杂度的问题很少.</p><h3 id="范式">2.1 范式</h3><p>因为只考虑判定问题而不是优化问题, 所以涉及到的只是 Simplex算法的变型, 通用 Simplex(general Simplex).后者并不涉及到目标函数求最值问题. 通用 Simplex算法接收两种约束类型作为输入:</p><ol type="1"><li><p>等式形式的公式 <span class="math display">\[a_1x_1+...+a_nx_n=0.\]</span></p></li><li><p>变量的上下界 <span class="math display">\[l_i\le x_i\le u_i.\]</span></p></li></ol><p>以上输入公式的形式称为一般形式(general form).一般形式的公式并入限制弱线性约束的建模能力,因为我们可以将任意的弱线性约束转换成上述的形式. 所谓弱线性约束即, <spanclass="math inline">\(L\Join R\)</span>, 其中的 <spanclass="math inline">\(\Join\in\{=,\le,\ge\}\)</span>. <spanclass="math inline">\(m\)</span> 表示约束的个数. 对于第 <spanclass="math inline">\(i\)</span> 个约束, <spanclass="math inline">\(1\le i\le m\)</span>:</p><ol type="1"><li><p>将 <span class="math inline">\(R\)</span>中的所有加数移到左侧以得到 <span class="math inline">\(L^\prime\Joinb\)</span>, 其中 <span class="math inline">\(b\)</span>是一个常数.</p></li><li><p>引入一个新的变量 <span class="math inline">\(s_i\)</span>.添加约束 <span class="math display">\[L^\prime-s_i=0\ {\rm and}\ s_i\Join b.\]</span> 如果 <span class="math inline">\(\Join\)</span> 是等式运算符,重写 <span class="math inline">\(s_i = b\)</span> 为 <spanclass="math inline">\(s_i\ge b\ \)</span> 和 <spanclass="math inline">\(\ s_i\le b\)</span>.</p></li></ol><p>转换过后, 原公式和现公式是等价的.</p><p>比如, 考虑如下约束合取式子: <span class="math display">\[\begin{aligned}x+y\ge 2 &amp;\ \land \\2x-y \ge 0 &amp;\ \land \\-x+ 2y \ge 1 &amp;\ .\end{aligned}\]</span> 该问题可以改写为如下一般形式: <span class="math display">\[\begin{aligned}x+y-s_1=0&amp;\ \land\\2x-y-s_2=0&amp;\ \land\\-x+2y-s_3=0&amp;\ \land\\s_1\ge 2&amp;\ \land\\s_2\ge 0&amp;\ \land\\s_3\ge 1&amp;\ .\end{aligned}\]</span> 新引入的变量 <span class="math inline">\(s_1,...s_m\)</span>称为附加变量(additional variables). 原约束中的变量 <spanclass="math inline">\(x_1,...,x_n\)</span> 称为问题变量(problemvariables). 因此, 转换之后的约束由 <spanclass="math inline">\(n\)</span> 个问题变量和 <spanclass="math inline">\(m\)</span> 个附加变量组成.</p><h3 id="simplex算法基础">2.2 Simplex算法基础</h3><p>通常将线性约束满足问题视为几何问题. 在几何体系下,每一个变量对应一个维度, 每一个约束就定义了一个凸子空间(convex subspace):特别地, 不等式定义半空间(half-spaces), 等式定义超平面(hyperplanes).满足赋值的(闭合)子空间由半空间和超平面的交点定义, 并形成凸多面体.凸子空间之间的交点也是凸的这一事实暗示了这一点. 同样地, 用一个 <spanclass="math inline">\(m\times(n+m)\)</span> 的矩阵 <spanclass="math inline">\(A\)</span> 来代表输入问题的系数. 变量 <spanclass="math inline">\(x_1,...,x_n,s_1,...,s_m\)</span> 重写为向量<strong>x</strong>. 据此, 上述问题的等价形式为存在一个向量<strong>x</strong> 使得 <span class="math display">\[A{\rm x} = 0\ {\rm and}\ \bigwedge_{i=1}^{m}l_i\le s_i\le u_i,\]</span> 其中, <spanclass="math inline">\(l_i\in\{-\infty\}\bigcup\mathbb{Q}\)</span> 是变量<span class="math inline">\(x_i\)</span> 的下界, <spanclass="math inline">\(u_i\in\{+\infty\}\bigcup\mathbb{Q}\)</span> 是变量<span class="math inline">\(x_i\)</span> 的上界. 继续上面的例子,将合取公式按 <span class="math inline">\(x,y,s_1,s_2,s_3\)</span>写成系数矩阵的形式 <span class="math display">\[\begin{pmatrix}1&amp; 1&amp; -1&amp; 0&amp; 0\\2&amp; -1&amp; 0&amp; -1&amp; 0\\-1&amp; 2&amp; 0&amp; 0&amp; -1\end{pmatrix}.\]</span> 那 <span class="math inline">\(m\)</span>个变量的集合对应的是列, 称为基本变量(basic variables), 记为 <spanclass="math inline">\(\mathcal{B}\)</span>, 也称为因变量,因为这些变量的值由哪些非基本变量(nonbasic variables)决定. 非基本变量记为<span class="math inline">\(\mathcal{N}\)</span>. 方便存储和操作矩阵<span class="math inline">\(A\)</span> 的一种表现形式称作<strong>tableau</strong>, 这是简化了矩阵 <spanclass="math inline">\(A\)</span>, 使其没有了对角子矩阵. 因此, tableau是一个 <span class="math inline">\(m\times n\)</span> 的矩阵, 其中,每一列对应的是非基本变量, 每一行与一个基本变量相关联.相同的基本变量在矩阵 <span class="math inline">\(A\)</span>中对角子矩阵的该行上具有"-1"条目. 因此,原来存储在对角矩阵中的信息现在由标记行的变量表示.</p><p>继续我们的例子, 转换后的 tableau 和范围约束如下</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><spanclass="math inline">\(s\)</span></th><th style="text-align: center;"><spanclass="math inline">\(y\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(s_1\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(s_2\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">-1</td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(s_3\)</span></td><td style="text-align: center;">-1</td><td style="text-align: center;">2</td></tr></tbody></table><p><span class="math display">\[\begin{aligned}2 \le s_1\\0 \le s_2\\1 \le s_3\end{aligned}\]</span></p><p>tableau 简化了矩阵 <span class="math inline">\(A\)</span> 的表达形式,因此 <span class="math inline">\(A\)</span>x=0 可以重写成 <spanclass="math display">\[\bigwedge_{x_i\in\mathcal{B}}(x_i =\Sigma_{x_j\in\mathcal{N}}a_{ij}x_j).\]</span></p><h3 id="带有上下界的-simplex-算法">2.3 带有上下界的 Simplex 算法</h3><p>通用 Simplex 算法除了 tableau 之外, 还维护一组赋值 <spanclass="math inline">\(\alpha: \mathcal{B\bigcupQ}\rightarrow\mathbb{Q}\)</span>. 算法按如下步骤初始化数据结构:</p><ul><li>基本变量集合 <span class="math inline">\(\mathcal{B}\)</span>就是附加变量的集合.</li><li>非基本变量结合 <span class="math inline">\(\mathcal{N}\)</span>就是问题变量的集合.</li><li>对于任意的 <span class="math inline">\(x_i, i\in{1,...,n+m},\alpha(x_i) = 0\)</span>.</li></ul>如果给所有变量的初始 0 赋值满足所有基本变量的上下界,那么可以说该公式是可满足的. 否则, 该算法开始修改赋值的处理程序. $$<span class="math display">\[\begin{aligned}&amp;\mathbf{Algorithm\ 1.}\ \rm{GENERAL\mbox{-}SIMPLEX}\\&amp;\mathbf{Input:}\ \rm{A\ linear\ system\ of\ constraints}\\mathcal{S}\\&amp;\mathbf{Output:}\ \rm{&#39;&#39;Satisfiable&#39;&#39;\ if\ the\system\ is\ satisfiable\ and\ &#39;&#39;Unsatisfiable&#39;&#39;\otherwise}\\&amp;\\&amp;1.\hspace{2mm}\rm{Transform\ the\ system\ into\ the\ general\form}\\&amp;\hspace{49mm}A\mathbf{x}=0\hspace{5mm} {\rmand}\hspace{5mm}\bigwedge^m_{i=1}l_i\le s_i\le u_i\\&amp;2.\hspace{2mm}{\rm Set\ }\mathcal{B}\ {\rm to\ be\ the\ set\ of\additional\ variables\ }s_1,...,s_m.\\&amp;3.\hspace{2mm}{\rm Construct\ the\ tableau\ for\ }A.\\&amp;4.\hspace{2mm}{\rm Determine\ a\ fixed\ order\ on\ the\variables}.\\&amp;5.\hspace{2mm}{\rm If\ there\ is\ no\ basic\ variable\ that\violates\ its\ bounds,\ return\ &#39;&#39;Satisfiable&#39;&#39;.\ }\\&amp;\hspace{5.5mm}{\rm Otherwise,\ let\ }x_i\ {\rm be the first\ basic\variable\ in\ the\ order\ that\ violates\ its\ bounds}.\\&amp;6.\hspace{2mm}{\rm Search\ for\ the\ first\ suitable\ nonbasic\variable\ }x_j\ {\rm in\ the\ order\ for\ pivoting\ with\ }x_i.\\&amp;\hspace{5.5mm}{\rm If\ there\ is\ no\ such\ variable,\ return\&#39;&#39;Unsatisfiable&#39;&#39;}.\\&amp;7.\hspace{2mm}{\rm Perform\ the\ pivot\ operation\ on\ }x_i\ {\rmand}\ x_j.\\&amp;8.\hspace{2mm}{\rm Go\ to\ step\ 5}.\end{aligned}\]</span><p>$$ 算法1 总结了通用 Simplex 算法的过程, 该算法包含两个不变式:</p><ul><li><p><strong>In-1.</strong> <spanclass="math inline">\(A\)</span>x=0</p></li><li><p><strong>In-2.</strong> 非基础变量的值总是在界定的范围内: <spanclass="math display">\[  \forall x_j\in \mathcal{N}.l_j\le \alpha(x_j)\le u_j.  \]</span></p></li></ul><p>显然, 这些不变式最初是成立的, 因为向量 <strong>x</strong>中的所有变量都设置为 0, 并且非基本变量没有界定上下界.</p><p>算法的主循环检查是否存在任一基本变量超过所规定的阈值.如果没有这样一个变量, 那么基本变量和非基本变量同时满足其自身的界限.由于不变式 <strong>In-1</strong>, 这意味着当前的赋值 <spanclass="math inline">\(\alpha\)</span> 是满足的,算法返回"Satisfiable".</p><p>否则, 让变量的 <span class="math inline">\(x_i\)</span>作为超出阈值的基本变量, 假定, 不失一般性地, <spanclass="math inline">\(\alpha(x_i)&gt;u_i\)</span>, 也就是说 <spanclass="math inline">\(x_i\)</span> 的赋值超过了规定的上界.那我们如何改变对于 <span class="math inline">\(x_i\)</span>的赋值使其满足阈值的要求? 我们需要找到减少 <spanclass="math inline">\(x_i\)</span> 值的方法. <spanclass="math inline">\(x_i\)</span> 的值是这样指定的: <spanclass="math display">\[x_i = \Sigma_{x_j\in \mathcal{N}} a_{ij}x_j.\]</span> 可以通过减小非基本变量 <spanclass="math inline">\(x_j\)</span> 的值来减小 <spanclass="math inline">\(x_i\)</span> 的值, 此时 <spanclass="math inline">\(a_{ij}&gt; 0\)</span>, 并且其当前赋值大于其下界<span class="math inline">\(l_j\)</span>, 或者通过增加非基本变量 <spanclass="math inline">\(x_j\)</span> 的值来减小 <spanclass="math inline">\(x_i\)</span> 的值, 此时 <spanclass="math inline">\(a_{ij}&lt;0\)</span>, 并且其当前赋值小于其上界<span class="math inline">\(u_j\)</span>. 任一变量 <spanclass="math inline">\(x_j\)</span> 满足其中一个条件就称为合适(suitable).如果不存在合适的变量, 那么该问题就是不可满足的并且算法终止.</p><p>用 <span class="math inline">\(\theta\)</span> 表示增加或者减少 <spanclass="math inline">\(\alpha(x_j)\)</span> 的大小, 以符合 <spanclass="math inline">\(x_i\)</span> 的上界要求: <spanclass="math display">\[\theta \doteq \frac{u_i - \alpha(x_i)}{a_{ij}}.\]</span> 将 <span class="math inline">\(x_j\)</span> 增加(或减少) <spanclass="math inline">\(\theta\)</span>, 将 <spanclass="math inline">\(x_i\)</span> 置于其自身的值域内. 另一方面, <spanclass="math inline">\(x_j\)</span> 不必再满足其值域, 因此可能违反不变式<strong>In-2</strong>. 因此, 我们在 tableau 中交换 <spanclass="math inline">\(x_i\)</span> 和 <spanclass="math inline">\(x_j\)</span>, 使 <spanclass="math inline">\(x_i\)</span> 为非基本变量, 而 <spanclass="math inline">\(x_j\)</span> 为基本变量. 这需要对 tabeau 进行转换,这称为变基操作. 重复执行变基操作, 直到找到可满足的赋值,或者判定系统不可满足.</p><h3 id="变基操作">2.4 变基操作</h3><p>在进行变量 <span class="math inline">\(x_i\)</span> 和 <spanclass="math inline">\(x_j\)</span> 的变换之前, 需要引入如下定义:</p><p>给定两个变量 <span class="math inline">\(x_i\)</span> 和 <spanclass="math inline">\(x_j\)</span>, 系数 <spanclass="math inline">\(a_{ij}\)</span> 称为轴元素(pivot element). 变量<span class="math inline">\(x_j\)</span> 所在的列称为轴列(pivot column).行 <span class="math inline">\(i\)</span> 称为轴行(pivot row).</p><p>变换两个变量的前提条件是它们的枢轴元素即系数不能是 0, 即 <spanclass="math inline">\(a_{ij}\ne0\)</span>. 变基操作如下:</p><ol type="1"><li>首先解决变量 <span class="math inline">\(x_j\)</span> 对应的行 <spanclass="math inline">\(i\)</span>.</li><li>对于所有的不等于 <span class="math inline">\(i\)</span> 的行 <spanclass="math inline">\(l\)</span>, 使用从行 <spanclass="math inline">\(i\)</span> 取得的关于 <spanclass="math inline">\(x_j\)</span> 的等式来消除 <spanclass="math inline">\(x_j\)</span>.</li></ol><p>这个过程其实就是高斯消元法(Gaussian variable elimination).</p><p>比如说, 对于上述的例子. 初始化赋值 <spanclass="math inline">\(\alpha(x_i)=0\)</span>. 针对上文的 tableau和约束条件.显然, <span class="math inline">\(s_1\)</span> 是大于等于 2的, 而初始赋值为 0, 所以不符合约束条件. 按顺序来说, 最低的非基本变量是<span class="math inline">\(x\)</span>. 变量 <spanclass="math inline">\(x\)</span> 的系数是正值, 没有上限约束,所以可以作为变基操作的变量. 需要对变量 <spanclass="math inline">\(s_1\)</span> 进行加 2 操作, 使得其能够满足大于等于2 的约束条件, 也就意味着变量 <span class="math inline">\(x\)</span>同时也要自增 2(<span class="math inline">\(\theta=2\)</span>).变基操作的第一步是对于 <span class="math inline">\(s_1\)</span> 所在行对<span class="math inline">\(x\)</span> 进行变换操作: <spanclass="math display">\[s_1=x+y\Longleftrightarrow x=s_1-y.\]</span> 该等式带入到其他行的等式中去: <span class="math display">\[\begin{aligned}s_2=2(s_1-y)-y&amp;\Longleftrightarrow s_2=2s_1-3y\\s_3=-(s_1-y)+2y&amp;\Longleftrightarrow s_3=-s_1+3y\end{aligned}\]</span> 写成表格形式:</p><table><thead><tr class="header"><th></th><th><span class="math inline">\(s_1\)</span></th><th><span class="math inline">\(y\)</span></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(x\)</span></td><td>1</td><td>-1</td></tr><tr class="even"><td><span class="math inline">\(s_2\)</span></td><td>2</td><td>-3</td></tr><tr class="odd"><td><span class="math inline">\(s_3\)</span></td><td>-1</td><td>3</td></tr></tbody></table><p><span class="math display">\[\begin{aligned}\alpha(x)&amp;=2\\\alpha(y)&amp;=0\\\alpha(s_1)&amp;=2\\\alpha(s_2)&amp;=4\\\alpha(s_3)&amp;=-2\\\end{aligned}\]</span></p><p>第一步变基操作之后, 可以看到变量 <spanclass="math inline">\(s_3\)</span> 也不满足其约束条件;这是下一步要进行变基操作的变量. 结合上文, 适合参与变换的是变量 <spanclass="math inline">\(y\)</span>. 需要在 <spanclass="math inline">\(s_3\)</span> 的基础上加上 3 才能满足其下界的要求.也就是说, <span class="math display">\[\theta=\frac{1-(-2)}{3}=1.\]</span> 在对变量 <span class="math inline">\(s_3\)</span> 和 <spanclass="math inline">\(y\)</span> 进行变换操作之后, 最终的 tableau 为</p><table><thead><tr class="header"><th></th><th><span class="math inline">\(s_1\)</span></th><th><span class="math inline">\(s_3\)</span></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(x\)</span></td><td>2/3</td><td>-1/3</td></tr><tr class="even"><td><span class="math inline">\(s_2\)</span></td><td>1</td><td>-1</td></tr><tr class="odd"><td><span class="math inline">\(y\)</span></td><td>1/3</td><td>1/3</td></tr></tbody></table><p>对应的赋值为 <span class="math display">\[\begin{aligned}\alpha(x)&amp;=1\\\alpha(y)&amp;=1\\\alpha(s_1)&amp;=2\\\alpha(s_2)&amp;=1\\\alpha(s_3)&amp;=1\\\end{aligned}\]</span> 该组赋值 <span class="math inline">\(\alpha\)</span>满足约束条件, 因此 <span class="math inline">\(\{x\mapsto 1,y\mapsto1\}\)</span> 是一组可满足的赋值.</p>]]></content>
    
    
    <categories>
      
      <category>判定过程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>线性规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>等式逻辑与未解释函数</title>
    <link href="/2022/01/cec5682c000f/"/>
    <url>/2022/01/cec5682c000f/</url>
    
    <content type="html"><![CDATA[<h2 id="等式逻辑">等式逻辑</h2><p>等式逻辑(equality logic)可以认为是命题逻辑,这种命题逻辑的原子都是等式, 等式两边是变量或者一边是变量一边是常数.等式逻辑的文法如下: <span class="math display">\[\begin{aligned}formula&amp;:formula\land formula\ |\ \neg formula\ |\ (formula)\ |\atom\\atom&amp;:term\ =\ term\\term&amp;:identifier\ |\ constant\end{aligned}\]</span> 举个例子, 公式 <span class="math inline">\((y=z\lor(\neg(x=z)\land x=2))\)</span> 是良形式的等式逻辑公式, 变量 <spanclass="math inline">\(x,y,z\in \mathbb{R}\)</span>. 一组可满足的赋值为<spanclass="math inline">\(\{x\mapsto2,y\mapsto2,z\mapsto0\}\)</span>.</p><p>针对等式逻辑的可满足性问题是属于 NPC 的,即确定性图灵机可以在较大的时间复杂度类别中求解它,并且可以在多项式时间内验证其解的问题. 实际上等式逻辑和命题逻辑都是 NPC问题, 这意味着二者可以对同一个判定问题进行建模.那么为什么还要引入等式逻辑呢? 主要有两个原因,</p><ol type="1"><li>方便建模 对于某些特定问题, 用等式逻辑进行建模要更加自然和方便,反之亦然.</li><li>高效 输入等式逻辑公式中的高阶结构可以潜在地用于使判定过程更快地工作.如果直接在命题逻辑中对问题进行建模, 则一些信息可能会丢失.</li></ol><p>通常来说, 等式逻辑公式中是有布尔变量的. 但是,我们并不应该把他们集成到理论的定义中, 这是为了保证算法描述尽可能简单.布尔变量能够通过在输入的公式中用两个新变量的等式关系替换掉. 但是,这并不是十分高效的解决办法. 后文将说明如何直接处理这些布尔变量.</p><h2 id="未解释函数">未解释函数</h2><p>等式逻辑在与未解释函数(uninterpretedfunctions)结合的时候会变得非常有用. 简单来说,未解释函数的作用就是用来抽象, 泛化或者定理化. 不像其他函数符号,未解释函数不应被解释为公式模型的一部分, 也就是说, 在公式中,未解释函数单单是一个未释义的函数. 比如说如下公式, <spanclass="math inline">\(F\)</span> 和 <spanclass="math inline">\(G\)</span> 是未解释的,二元运算符"+"就为常用的加法功能: <span class="math display">\[F(x)=F(G(y))\lor x+1=y.\]</span> 带有未解释函数的等式逻辑的文法定义如下: <spanclass="math display">\[\begin{aligned}formula &amp;: formula \land formula\ |\ \neg formula\ |\ (formula)\ |\atom\\atom &amp;: term = term\ |\ predicate-symbol\ (list\ of\ terms)\\term &amp;: identifier\ |\ function-symbol\ (list\ of\ terms)\\\end{aligned}\]</span> ### 未解释函数的使用</p><p>用未解释函数去替换公式中原本的函数时常用的技术,使得公式更容易推理(比如, 证明其有效性). 看如下推理规则: <spanclass="math display">\[\models\varphi^{UF}\Longrightarrow\ \models\varphi.\tag{1}\]</span> 其中 <span class="math inline">\(\models\varphi^{UF}\)</span>代表公式 <span class="math inline">\(\varphi\)</span>中一些或者全部函数被未解释函数替换后形成的公式.未解释函数被广泛应用于微积分和其他数学分支, 但是在推理和验证领域,主要应用于简化证明过程. 在某些情况下,未解释函数能够让我们在忽略一些后者全部函数语义的时候对系统进行推理,假设这些函数对于证明并不是必要的. 忽略函数的语义是指,一个解释并不需要为了满足公式而去满足这些原子.它唯一需要满足的是一个公理,该公理表明未解释的函数与任何函数一样都是一致的, 即给定相同的输入,它将返回相同的输出. 这是函数一致性(functional consistency)的要求.所谓函数一致性(功能一致性), 就是相同函数的实例接受相等的参数,那么返回值也是相等的. 有很多实例, 无论对于函数的解释如何,公式总是有效的. 在这些例子中, 未解释函数极大地简化了证明过程,尤其是在借助自动定理证明工具进行机械证明地时候.</p><p>假设我们有检查 EUF 公式的方法. 基于这个假设,使用未解释函数的基本框架如下:</p><ol type="1"><li>符号 <span class="math inline">\(\varphi\)</span>代表带有未解释函数的公式. 假设检查公式 <spanclass="math inline">\(\varphi\)</span> 的有效性的计算复杂度非常高,甚至无法计算.</li><li>对公式 <span class="math inline">\(\varphi\)</span>中的每一个函数都用一个与之对应的未解释的函数进行赋值, 并记新公式为 <spanclass="math inline">\(\varphi^{UF}\)</span>.</li><li>检查公式 <span class="math inline">\(\varphi^{UF}\)</span> 的有效性.如果它是有效的, 那么返回" <span class="math inline">\(\varphi\是有效的\)</span>". 否则, 返回"无法判定".</li></ol><p>步骤2的执行会付出一些代价, 因为会丢失信息. 就像上文提到的,它会导致验证过程的不完备, 即使原公式是属于可判定的逻辑. 由此,当一个对于输入公式的判定过程的计算太过复杂的时候, 可以设计一个程序将公式中函数的解释版本替换成未解释版本.</p><h3 id="例子-证明程序的等价性">例子: 证明程序的等价性</h3><p>考虑如下两个在功能上一致的 C 程序(a)和(b),目的是证明它们对于每一个可能的输入"in"都返回相同的值.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> in)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i, out_a;<br>    out_a = in;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)&#123;<br>        out_a = out_a * in;<br>    &#125;<br>    <span class="hljs-keyword">return</span> out_a;<br>&#125;<br></code></pre></td></tr></table></figure><center>(a)</center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func_new</span><span class="hljs-params">(<span class="hljs-keyword">int</span> in)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> out_b;<br>    out_b = (in * in) * in;<br>    <span class="hljs-keyword">return</span> out_b;<br>&#125;<br></code></pre></td></tr></table></figure><center>(b)</center><p>通常来说, 证明两个程序等价是不可判定的, 换句话说,没有一个既可靠又完备的方法证明这样的等价性. 但是在当前的例子中,等价性是可判定的.关于这些程序的一个关键是它们只有有限循环，因此可以计算它们的输入/输出关系。从这两个程序推导这些关系可以如下进行:</p><ol type="1"><li>移除变量声明和 return 语句.</li><li>展开 for 循环.</li><li>用新的辅助变量替换每个赋值语句中的左侧变量.</li><li>无论在何处读取变量(在表达式中引用), 都应使用辅助变量替换该变量,该辅助变量会在赋值的最后位置替换该变量.</li><li>将所有程序语句合取起来.</li></ol><p>上述操作的结果变为两个公式 <spanclass="math inline">\(\varphi_a\)</span> 和 <spanclass="math inline">\(\varphi_b\)</span> , 如下所示: <spanclass="math display">\[\begin{aligned}out0\_a&amp;=in0_a\ &amp;\land\\out1\_a&amp;=out0\_a*in0_a\ &amp;\land\\out2\_a&amp;=out1\_a*in0_a\\\\&amp;\hspace{10mm}(\varphi_a)\end{aligned}\]</span> <span class="math display">\[\begin{aligned}out0\_b&amp;=(in0_b*in0_b)*in0_b\\\\&amp;\hspace{10mm}(\varphi_b)\end{aligned}\]</span> 所以证明程序(a)和(b)等价性的问题就转化为,证明如下公式的有效性: <span class="math display">\[in0_a=in0_b\land\varphi_a\land\varphi_b\Longrightarrow out2_a=out0_b.\]</span> 未解释函数可以帮助证明程序(a)和(b)的等价性. 在这种情况下,这样做的动机是计算上的, 确定乘以例如64位变量的公式非常困难.用未解释函数替换乘法符号可以解决该问题. <span class="math display">\[\begin{aligned}out0\_a&amp;=in0\_a&amp;\land\\out1\_a&amp;=G(out0\_a,in0\_a)&amp;\land\\out2\_a&amp;=G(out1\_a,in0\_a)\\\\&amp;(\varphi^{UF}_a)\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}out0\_b&amp;=G(G(in0\_b,in0\_b),in0\_b)\\\\&amp;\hspace{3mm}(\varphi^{UF}_b)\end{aligned}\]</span></p><p>如上所示, <span class="math inline">\(\varphi^{UF}_a\)</span> 和<span class="math inline">\(\varphi^{UF}_b\)</span> 是在对公式 <spanclass="math inline">\((\varphi_a)\)</span> 和 <spanclass="math inline">\((\varphi_b)\)</span> 用未解释函数 <spanclass="math inline">\(G\)</span> 进行替换之后的公式. 所以现在,我们可以尝试验证 <span class="math display">\[\varphi^{UF}_a\land\varphi^{UF}_b\Longrightarrow\ out2\_a=out0\_b.\]</span></p><h2id="通过同余闭包判定等式和未解释函数的合取式">通过同余闭包判定等式和未解释函数的合取式</h2><p>现在说明一个用于解决等式逻辑和未解释函数合取式的方法.从变量和未解释函数的等式和不等式的合取式 <spanclass="math inline">\(\varphi^{UF}\)</span> 开始,基于计算等效类的算法有两个阶段.下面所示算法版本假设未解释函数只接收一个参数. 见算法1所示. <spanclass="math display">\[\begin{aligned}&amp;\mathbf{Algorithme\ 1:\ }{\rm CONGRUENCE\mbox{-}CLOSURE}\\&amp;\mathbf{Input:\ }{\rm A\ conjunction\ }\varphi^{UF}\ {\rm of\equality\ predicates\ over\ variables\ and\ uninterpreted\ functions}\\&amp;\mathbf{Output:\ }{\rm &#39;&#39;Satisfiable&#39;&#39;\ if\}\varphi^{UF}\ {\rm is\ satisfiable,\ and\&#39;&#39;Unsatisfiable&#39;&#39;\ otherwise}\\\\&amp;1.\hspace{2mm}{\rm Build\ congruence\mbox{-}closed\ equivalence\classes.}\\&amp;\hspace{6mm}{\rm (a)\ \ Initially,\ put\ two\ terms\ }t_1,t_2\ {\rm(either\ variables\ or\ uninterpreted\mbox{-}function\ instances)\ in\their\ }\\&amp;\hspace{15mm}{\rm own\ equivalence\ class\ if\ }(t_1=t_2)\ {\rm is\a\ predicate\ in\ }\varphi^{UF}.\ {\rm All\ other\ variables\ form\singleton\ }\\&amp;\hspace{15mm}{\rm equivalence\ classes.}\\&amp;\hspace{6mm}{\rm (b)\ Given\ two\ equivalence\ classes\ with\ a\shared\ term,\ merge\ them.\ Repeate\ until\ there\ are\ no\ }\\&amp;\hspace{15mm}{\rm more\ classes\ to\ be\ merged.}\\&amp;\hspace{6mm}{\rm (c)\ Compute\ the\ }congruence\ closure:{\rmgiven\ two\ terms\ }t_i,t_j\ {\rm that\ are\ in\ the\ same\ class\ and\that\ }\\&amp;\hspace{15mm}F(t_i)\ {\rm and\ }F(t_j){\rm\ are\ terms\ in\}\varphi^{UF}\ {\rm for\ some\ uninterpreted\ function\ }F,\ {\rm merge\the\ classes\ of\ }\\&amp;\hspace{15mm}F(t_i)\ {\rm and\ }F(t_j).\ {\rm Repeat\ util\ there\are\ no\ more\ such\ instances.}\\&amp;2.\hspace{2mm}{\rm If\ there\ exists\ a\ disequality\ }t_1\ne t_j\{\rm in\ }\varphi^{UF}\ {\rm such\ that\ }t_i {\rm and\ }t_j\ {\rm are\in\ the\ same\ equivalence\ class,\ }\\&amp;\hspace{6mm}{\rm returen\ &#39;&#39;Unsatisfiable&#39;&#39;.\Otherwise\ return\ &#39;&#39;Satisfiable&#39;&#39;.}\end{aligned}\]</span> 算法说明:</p><p>该算法的输入是变量和未解释函数的等式谓词的合取公式 <spanclass="math inline">\(\varphi^{UF}\)</span>; 输出是, 返回可满足如果公式<span class="math inline">\(\varphi^{UF}\)</span> 是可满足,否则返回不可满足.</p><ol type="1"><li><p>建立同余闭包等价类</p><ol type="a"><li><p>初始化,将两个项(变量或者未解释函数的实例)置入它们自己的等式集合中如果 <spanclass="math inline">\((t_1=t_2)\)</span> 是公式 <spanclass="math inline">\(\varphi^{UF}\)</span> 中的断言.所有其他变量构成单例等价类.</p></li><li><p>给定两个具有相同项的等价类, 将它们合并.重复直到不再有要合并的类.</p></li><li><p>计算同余闭包: 给定两个在同一个类中的项 <spanclass="math inline">\(t_i,t_j\)</span>, 并且 <spanclass="math inline">\(F(t_i)\)</span> 和 <spanclass="math inline">\(F(t_j)\)</span> 是公式中 <spanclass="math inline">\(\varphi^{UF}\)</span> 某些未解释函数的项, 合并<span class="math inline">\(F(t_i)\)</span> 和 <spanclass="math inline">\(F(t_j)\)</span>. 重复直到没有此类实例.</p></li></ol></li><li><p>如果在公式 <span class="math inline">\(\varphi^{UF}\)</span>中存在不等式 <span class="math inline">\(t_i\ne t_j\)</span>, 而且 <spanclass="math inline">\(t_i\)</span> 和 <spanclass="math inline">\(t_j\)</span> 是在同一个等价类中, 那么返回不可满足.否则返回可满足.</p></li></ol><p>比如, 考虑如下合取式 <span class="math display">\[\varphi^{UF} := x_1=x_2\land x_2=x_3\land x_4=x_5\land x_5\ne x_1\landF(x_1)\ne F(x_3).\]</span> 在初始步骤中, 等价类为 <span class="math display">\[\{x_1, x_2\},\{x_2, x_3\},\{x_4,x_5\},\{F(x_1)\},\{F(x_3)\}.\]</span> 步骤 1.b 合并前两个类: <span class="math display">\[\{x_1,x_2,x_3\},\{x_4,x_5\},\{F(x_1)\}, \{F(x_3)\}.\]</span> 下一步骤合并包含 <span class="math inline">\(F(x_1)\)</span>和 <span class="math inline">\(F(x_3)\)</span> 的类, 因为 <spanclass="math inline">\(x_1\)</span> 和 <spanclass="math inline">\(x_3\)</span> 在同一个类中: <spanclass="math display">\[\{x_1,x_2,x_3\},\{x_4,x_5\},\{F(x_1),F(x_3)\}.\]</span> 在步骤 2 中, 可见 <span class="math inline">\(F(x_1)\neF(x_3)\)</span> 是公式 <span class="math inline">\(\varphi^{UF}\)</span>的断言, 但是 <span class="math inline">\(F(x_1)\)</span> 和 <spanclass="math inline">\(F(x_3)\)</span> 是在同一个类中. 因此, 公式 <spanclass="math inline">\(\varphi^{UF}\)</span> 不可满足.</p>]]></content>
    
    
    <categories>
      
      <category>判定过程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>编译优化验证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DPLL Algorithm</title>
    <link href="/2022/01/be225a850aec/"/>
    <url>/2022/01/be225a850aec/</url>
    
    <content type="html"><![CDATA[<h1 id="dpllt-algorithm">DPLL(<span class="math inline">\(T\)</span>)Algorithm</h1><h2 id="无量词理论quantifier-free-theories">无量词理论(Quantifier-FreeTheories)</h2><p>考虑存在如下断言: <span class="math display">\[\begin{eqnarray*}&amp;&amp;(x_1=x_2\lor x_1=x_3)\land(x_1=x_2\lor x_1=x_4)\land x_1\neqx_2\land x_1\neq x_3 \land x_1\neq x_4, \tag{1}\\&amp;&amp;((x_1+2x_3&lt;5)\lor\neg(x_3\le1)\land(x_1\ge3)), \tag{2}\\&amp;&amp;(i=j\land a[j]=1)\land\neg(a[j]=1).\tag{3}\end{eqnarray*}\]</span></p><p>上述三个断言都是与之相对应的等式断言, 线性演算断言和数组逻辑断言.有一个通用的框架来定义这些断言, 就是一阶逻辑(first-order logic).需要注意的是, 上述三个公式都是无量词修饰(quantifier-free)的,或者说没有范阈限制, 一阶逻辑理论(first-order theory).</p><p>存在一个框架或者说一个判定过程,用以解决上述可判定的无量词一阶逻辑理论问题, 并且是由 CDCL 框架泛化而来,通常称为 DPLL(<span class="math inline">\(T\)</span>).</p><h2 id="dpllt-概述">DPLL(<span class="math inline">\(T\)</span>)概述</h2><p>每一个理论 <span class="math inline">\(T\)</span>都是定义在一个符号集合 <span class="math inline">\(\Sigma\)</span> 上的.在等式逻辑的例子中, <spanclass="math inline">\(\Sigma=\{&#39;=&#39;\}\)</span>. 当定义 <spanclass="math inline">\(\Sigma\)</span> 上的文字或者原子或者公式的时候,就意味着, 公式中的文字只能使用 <spanclass="math inline">\(\Sigma\)</span> 中的符合. 用 <spanclass="math inline">\(at(\varphi)\)</span> 表示一个给定否定范式公式<span class="math inline">\(\varphi\)</span> 的 <spanclass="math inline">\(\Sigma\)</span> 原子的集合, 用 <spanclass="math inline">\(at_i(\varphi)\)</span> 表示公式 <spanclass="math inline">\(\varphi\)</span> 中第 <spanclass="math inline">\(i\)</span> 个原子. 对于给定的原子 <spanclass="math inline">\(a\)</span>, 用 <spanclass="math inline">\(e(a)\)</span> 来表示这个原子的布尔编码,将其扩展到在符号集合 <span class="math inline">\(\Sigma\)</span>上的公式 <span class="math inline">\(t\)</span>, 用 <spanclass="math inline">\(e(t)\)</span> 来表示将 <spanclass="math inline">\(t\)</span>中的每一个原子对应的布尔编码代入公式所形成的布尔公式. 比如说, 如果 <spanclass="math inline">\(x=y\)</span> 是定义在符号集合 <spanclass="math inline">\(\Sigma\)</span> 上的原子命题, 那么布尔变量 <spanclass="math inline">\(e(x=y)\)</span> 就表示它的编码. 如果 <spanclass="math display">\[\varphi := x=y\lor x=z.\]</span> 是一个定义在符号集合 <spanclass="math inline">\(\Sigma\)</span> 上的公式(<spanclass="math inline">\(\Sigma\)</span>-formula), 那么 <spanclass="math display">\[e(\varphi) := e(x=y)\lor e(x=z).\]</span> 对于一个 <span class="math inline">\(\Sigma\)</span>-formula公式 <span class="math inline">\(\varphi\)</span> 来说, 布尔公式 <spanclass="math inline">\(e(\varphi)\)</span> 被称作公式 <spanclass="math inline">\(\varphi\)</span> 的命题框架(propositionalskeleton).</p><p>假设一个等式逻辑公式 <span class="math inline">\(\varphi\)</span>,<span class="math display">\[\varphi := x=y \land((y=z\land \neg(x=z))\lor x=z).\]</span> 公式 <span class="math inline">\(\varphi\)</span> 的命题框架是<span class="math display">\[e(\varphi) := e(x=y)\land((e(y=z)\land\neg e(x=z))\lor e(x=z)).\]</span> 布尔公式 <span class="math inline">\(\mathcal{B}\)</span>设值为 <span class="math inline">\(e(\varphi)\)</span>, 记为 <spanclass="math inline">\(\mathcal{B} := e(\varphi)\)</span>.</p><p>下一步, 将公式 <span class="math inline">\(\mathcal{B}\)</span>传给一个 SAT 求解器. 假设, 经过求解器的求解, SAT 给判定过程 <spanclass="math inline">\(DP_T\)</span> 返回了一组使得公式可满足的赋值.</p><blockquote><p><span class="math inline">\(DP_T\)</span>: 一个理论T(theory)是定义在符号集合 <span class="math inline">\(\Sigma\)</span>的, 符合理论 <span class="math inline">\(T\)</span> 定义的文字是 <spanclass="math inline">\(T\)</span>-文字, <spanclass="math inline">\(DP_T\)</span> 程序就是针对 <spanclass="math inline">\(T\)</span>-文字合取式的判定过程.</p></blockquote><p><span class="math display">\[\alpha := \{e(x=y)\mapsto {\rm TRUE}, e(y=z)\mapsto {\rm TRUE},e(x=z)\mapsto {\rm FALSE}\}.\]</span></p><p>判定过程 <span class="math inline">\(DP_T\)</span>要判定一组文字所对应的这组赋值的合取式是否是可满足的. 这个合取式记为<span class="math inline">\(\hat{Th(\alpha)}\)</span>.对于上面的一组赋值, <span class="math display">\[\hat{Th(\alpha)} := x=y\land y=z\land\neg(x=z).\]</span> 显然, 这个公式是不可满足的, 也就是说这个公式的否定是重言式.因此要被添加到公式 <span class="math inline">\(\mathcal{B}\)</span> 中,<em>这里说明一下, 为什么要把重言式添加到公式中,因为重言式并不会影响公式的判定结果, 为了提高判定过程的执行效率,就需要让求解器知道哪些赋值是无意义的, 比如此例,如果不将该重言式添加到公式</em> <spanclass="math inline">\(\mathcal{B}\)</span> <em>中, 那么 SAT求解器就可能重复赋值, 而影响判定过程的执行效率</em>. 该重言式的布尔编码:<span class="math display">\[e(\neg\hat{Th(\alpha)}) := (\neg e(x=y)\lor\neg e(y=z)\lor e(x=z)).\]</span> 这个子句是与当前的赋值相矛盾的, 所以要阻止其被重复赋值.这种子句称为封锁子句(blocking clause). 通常, 将 <spanclass="math inline">\(DP_T\)</span> 过程所返回的结果记为 <spanclass="math inline">\(t\)</span>, 也称为引理(lemma). 在上述例子中, <spanclass="math inline">\(t := \neg\hat{Th(\alpha)}\)</span>, 也就是说,这个引理是完全赋值 <span class="math inline">\(\alpha\)</span> 的否定,并且是一个子句, 但是通常 <span class="math inline">\(t\)</span>是多子句的形式, 这取决于 <span class="math inline">\(DP_T\)</span>的实现形式.</p><p>在封锁子句添加到公式中后, SAT 求解器再次被调用并给公式赋新值, 比如说,<span class="math display">\[{\alpha}&#39; := \{ e(x=y)\mapsto {\rm TRUE}, e(y=z)\mapsto{\rm TRUE},e(x=z)\mapsto{\rm TRUE} \}.\]</span> 那么, 对应的 <span class="math inline">\(\Sigma\)</span>-公式<span class="math display">\[{\hat Th(\alpha&#39;)} := x=y\land y=z\land x=z.\]</span> 是可满足的, 也说明原公式 <spanclass="math inline">\(\varphi\)</span> 是可满足的. 可以看到, 只要是满足<span class="math inline">\({\hat Th(\alpha&#39;)}\)</span>的赋值同样是满足公式 <span class="math inline">\(\varphi\)</span>的.</p><p>当然, 如果原公式 <span class="math inline">\(\varphi\)</span>大小线性甚至指数增加, 通过完全赋值的方法显然效率很低.有很多种提升效率的方法, 在对子句进行部分赋值之后即调用判定过程 <spanclass="math inline">\(DP_T\)</span>, 而不是等到全部赋值之后.一组相矛盾的部分赋值能够得到更加强大的引理 <spanclass="math inline">\(t\)</span>, 因为它可以组织所有对它进行扩展的赋值.另外, 如果一组部分赋值不是矛盾的, 那也可以回传给 SAT求解器用以更进一步的推导. 比如上面的例子, 存在一组部分赋值 <spanclass="math display">\[\alpha := \{ e(x=y)\mapsto {\rm TRUE}, e(y=z) \mapsto {\rm TRUE} \}.\]</span> 所对应要传递给 <span class="math inline">\(DP_T\)</span>的合取公式 <span class="math display">\[{\hat Th(\alpha)} := x=y\land y=z.\]</span> 这个公式能够让 <span class="math inline">\(DP_T\)</span>推导出 <span class="math inline">\(x=z\)</span>, 同时能够让 SAT求解器知道, 根据当前的部分赋值 <spanclass="math inline">\(\alpha\)</span> 能够推导出 <spanclass="math inline">\(e(x=z)\mapsto {\rm TRUE}\)</span>. 因此, 类比在SAT 求解器种的布尔约束传播(Boolean constraint propagation),这里可以称作是理论传播(theory propagation).这种传播可能会导致进一步的布尔约束传播, 也就是说这个过程在 SAT求解器做出下一个判定之前可能会迭代很多次.</p><p>现在引出一个算法, LAZY-BASIC(算法1), 用以判定一个 <spanclass="math inline">\(T\)</span>-公式 <spanclass="math inline">\(\varphi\)</span> 是否是可满足的. 这个算法的做法是,从公式 <span class="math inline">\(\mathcal{B}=e(\varphi)\)</span> 开始,迭代地对命题公式 <span class="math inline">\(\mathcal{B}\)</span>进行求解,并用DEDUCTION(演绎推理)方法计算出的约束条件的编码逐步增强这一过程. <spanclass="math display">\[\begin{aligned}&amp;\mathbf{Algorithm\ 1:}\ \rm LAZY\mbox{-}BASIC\\&amp;\mathbf{Input:}\ {\rm A\ formula}\ \varphi\\&amp;\mathbf{Output:}\ {\rm &#39;&#39;Satisfiable&#39;&#39;\ if}\\varphi\ {\rm is\ satisfiable,\ and\ &#39;&#39;Unsatisfiable&#39;&#39;\otherwise}\\&amp;\\&amp;1.\hspace{2mm}\mathbf{function\ }{\rm LAZY\mbox{-}BASIC}(\varphi)\\&amp;2.\hspace{10mm}\mathcal{B}:=e(\varphi);\\&amp;3.\hspace{10mm}\mathbf{while\ }{\rm(TRUE)\ }\mathbf{do}\\&amp;4.\hspace{16mm}\langle\alpha,res\rangle:={\rmSAT\mbox{-}SOLVER}(\mathcal{B});\\&amp;5.\hspace{16mm}\mathbf{if\ }res={\rm&#39;&#39;Unsatisfiable&#39;&#39;\ }\mathbf{then\ return\ }{\rm&#39;&#39;Unsatisfiable&#39;&#39;};\\&amp;6.\hspace{16mm}\mathbf{else}\\&amp;7.\hspace{23mm}\langle t,res\rangle:={\rmDEDUCTION}(\hat{Th}(\alpha));\\&amp;8.\hspace{23mm}\mathbf{if\ }res={\rm&#39;&#39;Satisfiable&#39;&#39;\ }\mathbf{then\ return\ }{\rm&#39;&#39;Satisfiable&#39;&#39;};\\&amp;9.\hspace{23mm}\mathcal{B}:=\mathcal{B}\land e(t);\end{aligned}\]</span> LAZY-BASIC算法其实在上一小节已经大致说明了, 这里再总结一下.算法首先将公式 <span class="math inline">\(\varphi\)</span>进行布尔编码赋值给 <span class="math inline">\(\mathcal{B}\)</span>,进入循环体. 公式 <span class="math inline">\(\mathcal{B}\)</span> 传给SAT 求解器, 并返回一个元组 <span class="math inline">\(&lt;assignment,result&gt;\)</span>, 其中 <spanclass="math inline">\(assignment\)</span>中包含的就是使得公式 <spanclass="math inline">\(\mathcal{B}\)</span> 可满足的一组赋值, 而 <spanclass="math inline">\(result\)</span> 是说明公式是否可满足; 进入判断,如果不可满足, 那么整个公式就是不可满足的. 否则, 将布尔编码对应的 <spanclass="math inline">\(T\)</span>-文字合取式传给 DEDUCTION(), 判断 <spanclass="math inline">\(\hat{Th(\alpha)}\)</span> 公式是否是可满足的,并同样返回一个元组; 如果结果是可满足的, 如前文所说,那么整个公式就是可满足的. 否则, 就把这组赋值对应的布尔编码添加到公式<span class="math inline">\(\mathcal{B}\)</span> 中, 以防止重复赋值.当然, 可以把这个算法集成到 CDCL-SAT 中去, 以获得更高的效率. 算法2就是在CDCL-SAT 求解器中集成了 DEDUCTION方法的算法. <spanclass="math display">\[\begin{aligned}&amp;\mathbf{Algorithm\ 2:\ }{\rm LAZY\mbox{-}CDCL}\\&amp;\mathbf{Input:}\ {\rm A\ formula}\ \varphi\\&amp;\mathbf{Output:}\ {\rm &#39;&#39;Satisfiable&#39;&#39;\ if\ the\formula\ }\ {\rm is\ satisfiable,\ and\&#39;&#39;Unsatisfiable&#39;&#39;\ otherwise}\\\\&amp;1.\hspace{2mm}\mathbf{function}\ {\rm LAZY\mbox{-}CDCL} \\&amp;2.\hspace{10mm}{\rm ADDCLAUSES}(cnf(e(\varphi))); \\&amp;3.\hspace{10mm}\mathbf{while\ }{\rm TRUE\ }\mathbf{do} \\&amp;4.\hspace{18mm}\mathbf{while\ }{\rm (BCP()\ =\&#39;&#39;conflict&#39;&#39;)}\ \mathbf{do} \\&amp;5.\hspace{26mm}backtrack\mbox{-}level:={\rmANALYZE\mbox{-}CONFLICT()}; \\&amp;6.\hspace{26mm}\mathbf{if\ }backtrack\mbox{-}level&lt;0\\mathbf{then\ return\ }{\rm &#39;&#39;Unsatisfiable&#39;&#39;}; \\&amp;7.\hspace{26mm}\mathbf{else\ }{\rmBackTrack}(backtrack\mbox{-}level);\\&amp;8.\hspace{18mm}\mathbf{if\ }{\rm \neg DECIDE()\}\mathbf{then}\hspace{55mm}\triangleright\ {\rm Full\ assignment} \\&amp;9.\hspace{26mm}\langle t,res\rangle:={\rmDEDUCTION}(\hat{Th}(\alpha));\hspace{19.5mm}\triangleright\ {\rm \alpha\is\ the\ assignment}\\&amp;10.\hspace{24mm}\mathbf{if\ }res={\rm&#39;&#39;Satisfiable&#39;&#39;\ }\mathbf{then\ return\ }{\rm&#39;&#39;Satisfiable&#39;&#39;};\\&amp;11.\hspace{24mm}{\rm ADDCLAUSES}(e(t)); \\\end{aligned}\]</span></p><h3 id="理论传播和dpllt框架">理论传播和DPLL(<spanclass="math inline">\(T\)</span>)框架</h3><p>但是 LAZY-CDCL 算法可以进一步优化. 比如说, 在公式 <spanclass="math inline">\(\varphi\)</span> 中有一个变量 <spanclass="math inline">\(x_1\)</span>, 存在两个文字分别是 <spanclass="math inline">\(x_1\ge 10\)</span> 和 <spanclass="math inline">\(x_1\lt 0\)</span>. 假设在 DECIDE() 过程中,两个文字分别被赋值为 <span class="math inline">\(e(x_1\ge 10)\mapsto \rmTRUE\)</span> 和 <span class="math inline">\(e(x_1\lt 0)\mapsto \rmTRUE\)</span>. 不可避免地，任何对DEDUCTION()的调用都会存在这两个事实之间的矛盾, 而与任何其他判定无关.但是算法2直到完全赋值之后才执行 <spanclass="math inline">\(then\)</span> 之后的语句,所以用以进行完全赋值的时间就被浪费了. 而且, 如果完全赋值被拒绝了,也就是说一组完全复制不能使公式可满足,那么可能是由于一组赋值的子集存在矛盾的情况, 换句话说,上述错误的赋值可能并没有被排除在外, 这就造成了效率的极大降低. 所以,可以考虑把 DEDUCTION 提前, 在未完全赋值之前执行. 这样做有两个目的:</p><ol type="1"><li>矛盾的赋值可以尽早排除.</li><li>那些尚未被赋值的蕴涵信息可以告知 SAT 求解器. 继续上述例子, 如果<span class="math inline">\(e(x_1\ge 10)\mapsto \rm TRUE\)</span>,那么就可一断定 <span class="math inline">\(e(x_2\lt 0)\)</span> 赋值为<span class="math inline">\(\rm FALSE\)</span>, 以避免冲突的赋值.</li></ol><p>这就引出了优化之后的算法, DPLL(<spanclass="math inline">\(T\)</span>). 如算法3所示. <spanclass="math display">\[\begin{aligned}&amp;\mathbf{Algorithm\ 3:\ }{\rm DPLL}(T)\\&amp;\mathbf{Input:}\ {\rm A\ formula}\ \varphi\\&amp;\mathbf{Output:}\ {\rm &#39;&#39;Satisfiable&#39;&#39;\ if\ the\formula\ }\ {\rm is\ satisfiable,\ and\&#39;&#39;Unsatisfiable&#39;&#39;\ otherwise}\\\\&amp;1.\hspace{2mm}\mathbf{function}\ {\rm DPLL}(T) \\&amp;2.\hspace{10mm}{\rm ADDCLAUSES}(cnf(e(\varphi))); \\&amp;3.\hspace{10mm}\mathbf{while\ }{\rm TRUE\ }\mathbf{do} \\&amp;4.\hspace{18mm}\mathbf{repeat}\\&amp;5.\hspace{26mm}\mathbf{while\ }{\rm (BCP()\ =\&#39;&#39;conflict&#39;&#39;)}\ \mathbf{do} \\&amp;6.\hspace{34mm}backtrack\mbox{-}level:={\rmANALYZE\mbox{-}CONFLICT()}; \\&amp;7.\hspace{34mm}\mathbf{if\ }backtrack\mbox{-}level&lt;0\\mathbf{then\ return\ }{\rm &#39;&#39;Unsatisfiable&#39;&#39;}; \\&amp;8.\hspace{34mm}\mathbf{else\ }{\rmBackTrack}(backtrack\mbox{-}level);\\&amp;9.\hspace{26mm}\langle t,res\rangle:={\rmDEDUCTION}(\hat{Th}(\alpha));\\&amp;10.\hspace{24mm}{\rm ADDCLAUSES}(e(t));\\&amp;11.\hspace{16mm}\mathbf{until\ }t\equiv{\rm TRUE};\\&amp;12.\hspace{16mm}\mathbf{until\ }\alpha\ {\rm is\ a\ }full\ {\rmassignment\ }\mathbf{then\ return\ }{\rm&#39;&#39;Satisfiable&#39;&#39;};\\&amp;13.\hspace{16mm}{\rm DECIDE()};\\\end{aligned}\]</span> 下面对 DPLL(<span class="math inline">\(T\)</span>)做简要说明. 内层的 while 循环还是执行布尔约束传导判断是否存在冲突, 这与CDCL 算法的主要部分是一致的. 重要的是集成了 DEDUCTION(),判断文字布尔编码对应的合取范式是否是可满足的.不论是否可满足都将其加入到原公式中去, 如果是可满足,那么不影响最终判定结果; 如果不满足, 那么就将矛盾的赋值排除在外. 外层的repeate 循环直到 DEDUCTION() 返回的结果为真时结束. 并判断赋值公式 <spanclass="math inline">\(\alpha\)</span> 是否是完全赋值, 如果是完全赋值,则原公式可满足. 否则, 同样执行 CDCL 算法中的 DECIDE() 方法,判断是否没有再可以赋值的变量了, 循环继续. 该算法相较于 CDCL算法主要的不同之处就在于(当然是对于等式逻辑来说的),对于子句的部分赋值对应布尔编码的合取式子进行了可满足性的判定,并通过理论传播策略, 加速了判定过程的执行,并尽可能早地将造成矛盾条件的赋值剔除, 以达到较好的性能.</p>]]></content>
    
    
    <categories>
      
      <category>判定过程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>DPLL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CDCL Algorithm</title>
    <link href="/2022/01/ecd0f787ac3d/"/>
    <url>/2022/01/ecd0f787ac3d/</url>
    
    <content type="html"><![CDATA[<h2 id="conflict-driven-clause-learningcdcl-algorithm">1 Conflict-DrivenClause Learning(CDCL) Algorithm</h2><p>SAT 求解器可以被分为两类,一类是基于冲突驱动的子句学习框架的算法或者组合算法;一类是基于随机搜索(stochastic search)的算法. 根据经验来看, 基于 CDCL的算法在大多数情况下, 针对 CNF 公式的求解性能要优于随机搜索.所以着重学习一下 CDCL 和 DPLL 对 SAT 求解问题会有更加深入的了解.</p><h3 id="cdcl-sat算法">CDCL-SAT算法</h3><p><span class="math display">\[\begin{aligned}&amp;\mathbf{Algorithm\ 1.}\ \rm{CDCL\mbox{-}SAT}\\&amp;\mathbf{Input:}\ \rm{A\ propositional\ CNF\ formula}\ \mathcal{B}\\&amp;\mathbf{Output:}\ \rm{&#39;&#39;Satisfiable&#39;&#39;\ if\ the\formula\ is\ satisfiable\ and\ &#39;&#39;Unsatisfiable&#39;&#39;\otherwise}\\&amp;\\&amp;1.\hspace{2mm}\mathbf{function}\ \rm{CDCL}\\&amp;2.\hspace{10mm}\mathbf{while}\ \rm{(TRUE)}\ \mathbf{do}\\&amp;3.\hspace{18mm}\mathbf{while}\ \rm{(BCP()\ =\&#39;&#39;CONFLICT&#39;&#39;)}\ \mathbf{do}\\&amp;4.\hspace{25mm}backtrack\mbox{-}level:=\rm{ANALYZE\mbox{-}CONFLICT()};\\&amp;5.\hspace{25mm}\mathbf{if}\ backtrack\mbox{-}level\lt 0\mathbf{then\ return}\ \rm{&#39;&#39;Unsatisfiable&#39;&#39;};\\&amp;6.\hspace{25mm}{\rm BackTrack}(backtrack\mbox{-}level);\\&amp;7.\hspace{18mm}\mathbf{if}\ \neg{\rm DECIDE()}\ \mathbf{then\return}\ {\rm &#39;&#39;Satisfiable&#39;&#39;};\end{aligned}\]</span></p><p>如算法1 所示, CDCL 求解器接受一个 CNF 合取范式公式 <spanclass="math inline">\(\mathcal{B}\)</span> 作为输入,输出为该公式是否为可满足的. 算法执行到循环体内,当通过执行布尔约束传播(BCP)函数得到冲突结果时, 算法进入第二层循环.在分析冲突子句(conflict clause)之后, ANALYZE-CONFLICT()函数返回一个回溯层(backtrack-level)的值并且生成一组新的冲突子句. 此时,如果要回溯的决策层的值小于零, 那么说明此 CNF公式不可满足(因为如果回溯结果小于零, 就说明不存在一组赋值使得 CNF公式整体为真); 反之, 执行回溯函数 BackTrack(), 并回溯到决策层backtrack-level(). 如果没有侦测到冲突, 那么执行 DECIDE() 函数,判断是否还有未被赋值的文字, 如果都被赋值了, 那么公式 <spanclass="math inline">\(\mathcal{B}\)</span> 是可满足的, 否则循环继续.</p><p>以上是 CDCL 框架的整体思路, 但是这里存在两个问题需要进行深究: 1)如何对冲突子句进行分析, 也就是函数ANALYZE-CONFLICT() 是如何工作的. 2)函数DECIDE() 如何能够快速且高效地判断已赋值和未赋值的变量,并赋真值给尚未赋值的变量.</p><h2 id="analyze-conflict-算法">2 ANALYZE-CONFLICT 算法</h2><p>先说明第一个问题. ANALYZE-CONFLICT()负责从先前得出的冲突子句和冲突蕴涵图推导出新的冲突子句并计算出 CDCL算法所要回溯的决策层. ANALYZE-CONFLICT() 在冲突蕴涵图上从冲突节点回溯,并通过<strong>一系列步骤</strong>生成新的冲突子句.以下对该算法进行说明.</p><p><span class="math display">\[\begin{aligned}&amp;\mathbf{Algorithm\ 2.}\ \rm{ANALYZE\mbox{-}CONFLICT}\\&amp;\mathbf{Input:}\\&amp;\mathbf{Output:}\ \rm{Backtracking\ decision\ level\ +\ a\ new\conflict\ clause}\\&amp;\\&amp;1.\hspace{2mm}\mathbf{if}\ current\mbox{-}decision\mbox{-}level=0\\mathbf{then\ return}\ -1;\\&amp;2.\hspace{2mm}cl:=current\mbox{-}conflicting\mbox{-}clause;\\&amp;3.\hspace{2mm}\mathbf{while}\ ({\rm \negSTOP\mbox{-}CRITERION\mbox{-}MET}(cl))\ \mathbf{do}\\&amp;4.\hspace{10mm}lit:={\rmLAST\mbox{-}ASSIGNED\mbox{-}LITERAL}(cl);\\&amp;5.\hspace{10mm}var:={\rm VARIABLE\mbox{-}OF\mbox{-}LITERAL}(lit);\\&amp;6.\hspace{10mm}ante:={\rm ANTECEDENT}(lit);\\&amp;7.\hspace{10mm}cl:={\rm RESOLVE}(cl,\ ante,\ var);\\&amp;8.\hspace{2mm}{\rmadd\mbox{-}clause\mbox{-}to\mbox{-}database}(cl);\\&amp;9.\hspace{2mm}\mathbf{return}\ {\rmclause\mbox{-}asserting\mbox{-}level}(cl);\hspace{15mm} \triangleright\{\rm 2nd\ highest\ decision\ level\ in\ } cl\end{aligned}\]</span></p><p>如算法2 所示, ANALYZE-CONFLICT 算法的输出正如前文所述,即回溯决策层并产生一组新的冲突子句(断言子句). 如果当前的决策层的值为0,那么返回-1, 随之的结果就是在 CDCL 求解器中判定公式 <spanclass="math inline">\(\mathcal{B}\)</span> 不可满足. 否则, 变量 <spanclass="math inline">\(cl\)</span> 记为当前冲突子句, 并进入循环体.循环的判断条件 STOP-CRITERION-MET(cl), 一个比较好的策略是, 在当前决策层,当且仅当 <span class="math inline">\(cl\)</span>包含第一个唯一蕴涵节点(UIP)的否定, 结果就返回"真". 循环体内部,将当前冲突子句的最后一个赋值文字赋值给变量 <spanclass="math inline">\(lit\)</span>. 将 <spanclass="math inline">\(lit\)</span> 中的变量(即没有逻辑连接符<spanclass="math inline">\(\neg\)</span>的文字)赋值给 <spanclass="math inline">\(var\)</span>. <spanclass="math inline">\(lit\)</span> 的前件赋值给 <spanclass="math inline">\(ante\)</span>, 所谓前件就是仅由 <spanclass="math inline">\(lit\)</span> 决定真值的子句(clause). 循环体最后,更新当前冲突子句 <span class="math inline">\(cl\)</span> 的值,这个更新策略为 RESOLVE(<span class="math inline">\(cl\)</span>, <spanclass="math inline">\(ante\)</span>, <spanclass="math inline">\(var\)</span>). 循环结束之后, 更新数据库,并返回决策层级.先说明策略 RESOLVE 的作用. 该策略涉及到一个概念,即二元解析(Binary Resolution). 考虑如下推导规则:</p><p><span class="math display">\[\begin{aligned}\frac{(a_1 \lor\ ...\ a_n\lor\ \beta)\  (b_1\lor\ ...\ b_n\lor\\neg\beta)}{(a_1\lor...\lor a_n\lor b_1 ...\lor b_n)}\end{aligned}\]</span> 其中, <spanclass="math inline">\(a_1,...,a_n,b_1,...b_n\)</span> b 表示文字, <spanclass="math inline">\(\beta\)</span> 表示变量. 变量 <spanclass="math inline">\(\beta\)</span> 被称作解析变量(resolutionvariable). 两个子句 <span class="math inline">\((a_1 \lor\ ...\ a_n\lor\\beta)\ \)</span> 和 <span class="math inline">\((b_1\lor\ ...\ b_n\lor\\neg\beta)\)</span> 是待解析子句, 最终结果 <spanclass="math inline">\((a_1\lor...\lor a_n\lor b_1 ...\lor b_n)\)</span>是已解析子句. 显而易见, 二元解析的作用是将两个含有同一个变量 <spanclass="math inline">\(\beta\)</span>的析取子句合并成不含公共变量的析取子句. 由此,基于二元解析规则的演绎推理系统是可靠且完备的. 换句话说,当且仅当存在一个以空子句结束的有限二元解析步骤的序列时, 这样一个 CNF公式是不可满足的. 用一个简单的例子说明二元解析和 RESOLVE 策略.</p><p><img src="\img\CDCL-Algorithm\conflict-graph.png" style="zoom:50%;" /></p><center>图1 RESOLVE策略</center><p>如图1 所示的冲突蕴涵子图, 整个 ANALYZE-CONFLICT算法的作用就是从图中的冲突节点 <spanclass="math inline">\(\mathcal{k}\)</span> 开始从右向左回溯,以产生新的冲突子句. 该蕴涵图的结果是产生一个当前的冲突子句 <spanclass="math inline">\(c_5 := (x_{10}\lor x_2\lor \neg x_4)\)</span>.ANALYZE-CONFLICT 从冲突子句 <span class="math inline">\(c_4\)</span>处回溯整个蕴涵图, 回溯过程如下表1所示.</p><p>表1. 回溯过程</p><table><colgroup><col style="width: 15%" /><col style="width: 52%" /><col style="width: 15%" /><col style="width: 7%" /><col style="width: 9%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(\rmName\)</span></th><th style="text-align: center;"><spanclass="math inline">\(cl\)</span></th><th style="text-align: center;"><spanclass="math inline">\(lit\)</span></th><th style="text-align: center;"><spanclass="math inline">\(var\)</span></th><th style="text-align: center;"><spanclass="math inline">\(ante\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(c_4\)</span></td><td style="text-align: center;"><span class="math inline">\((\negx_6\lor x_7)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(x_7\)</span></td><td style="text-align: center;"><spanclass="math inline">\(x_7\)</span></td><td style="text-align: center;"><spanclass="math inline">\(c_3\)</span></td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;"><span class="math inline">\((\negx_5\lor\neg x_6)\)</span></td><td style="text-align: center;"><span class="math inline">\(\negx_6\)</span></td><td style="text-align: center;"><spanclass="math inline">\(x_6\)</span></td><td style="text-align: center;"><spanclass="math inline">\(c_2\)</span></td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;"><span class="math inline">\((\negx_4\lor x_{10}\lor \neg x_5)\)</span></td><td style="text-align: center;"><span class="math inline">\(\negx_5\)</span></td><td style="text-align: center;"><spanclass="math inline">\(x_5\)</span></td><td style="text-align: center;"><spanclass="math inline">\(c_1\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(c_5\)</span></td><td style="text-align: center;"><span class="math inline">\((\negx_4\lor x_2\lor x_{10})\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p>子句 <span class="math inline">\(c_5\)</span> 是一个断言子句,在这个子句中，第一个 UIP(<span class="math inline">\(x_4\)</span>)的否定是来自当前决策层的唯一文字.</p><h2 id="decide策略">3 DECIDE策略</h2><p>第二个问题, DECIDE 策略的选择. 在 SAT求解过程中最重要的部分就是选择变量并给已选变量赋值的策略, 这个策略就是SAT 求解器的启发式判定(decision heuristic)策略.先介绍几个常见的启发式判定策略.</p><h3 id="jeroslow-wang">3.1 Jeroslow-Wang</h3><p>其实最容易想到的就是 Jeroslow-Wang 策略,只要找到在每一个子句中出现次数最多的那个文字就行了. 对于给定的CNF公式<span class="math inline">\(\mathcal{B}\)</span>, 计算每一个文字 <spanclass="math inline">\(l\)</span> <span class="math display">\[J(l)\ = \Sigma_{\omega \in \mathcal{B}, l\in\omega}2^{-|\omega|}\]</span> 其中 <span class="math inline">\(\omega\)</span> 代表一个子句,相应地, <span class="math inline">\(|\omega|\)</span> 表示该子句的长度.选择出一个使得 <span class="math inline">\(J(l)\)</span> 值最大的文字<span class="math inline">\(l\)</span>, 也就是尚未被赋值的那个文字.这个策略给予在短子句中出现频率最高的文字较高的优先等级,可以被静态或者动态实现. 显然,动态实现方法在每个决策点会导致很大的性能开销.</p><h3 id="动态最大单项和dynamic-largest-individual-sum-dlis">3.2动态最大单项和(Dynamic Largest Individual Sum, DLIS)</h3><p>在每一个决策层, 选择满足当前为满足子句数量最多的尚未赋值的文字.实现这种启发式方法的常见方法是将每个文字的指针指向它所出现的子句列表中.在每个决策层, 求解器计算包含这个文字但尚未满足的子句数量,并将这个数字分配给该文字. 随后, 选择计数最多的文字. 同样, DLIS也导致很大的开销, 因为做出决策的复杂度与子句的数量成正比.</p><h3id="变量状态下的独立衰减和variable-state-independent-decaying-sum-vsids">3.3变量状态下的独立衰减和(Variable State Independent Decaying Sum,VSIDS)</h3><p>这是 SAT 求解器 Chaff 中引入的一种策略. 首先,在计算每个文字出现的子句数量时, 不考虑该子句是否已经满足的问题.这意味着, 对每一个决策的质量都会受到影响, 但是做出决策的复杂度会更好:假设我们把文字保存在一个列表中, 按照各自的分数排序,做出判定只需要需要常数时间. 其次, 定期将所有分数除以 2.</p><p>该决策的思路是使启发式决策基于冲突驱动,意思就是说它试图首先解决最近发现的冲突. 为此,它需要给近期冲突中所涉及到的变量更高的分数.每一次冲突都会产生一个冲突子句. 一个新的冲突子句, 和其他子句一样,每出现一个文字就加1分. 这个子句被添加后时间越长, 这些文字的分数被 2整除的次数就越多. 因此, 变量在新的冲突子句中就变得更有影响力. 引入了VSIDS 的 SAT 求解器 Chaff,允许人们通过控制分数的被除频率和除数来调整这一策略. 针对不同 CNF公式的解法最好是要有不同的参数.</p><p>还有另外一个基于冲突驱动的启发式方法. 比如说, MINISAT求解器所采用的策略. MINISAT为每一个变量保存一个双精度浮点型的活动分数(activity score),用来衡量每一个变量推导出新子句的参与度. 如果一个子句 <spanclass="math inline">\(c\)</span> 可以从其他子句 <spanclass="math inline">\(c_1,...,c_n\)</span> 推导得出, 那么在子句 <spanclass="math inline">\(c_1,..c_n\)</span> 中的每一个实例的变量 <spanclass="math inline">\(v\)</span> 都会以常量 <spanclass="math inline">\(inc\)</span> 的方式增加. <spanclass="math inline">\(inc\)</span> 初始值设为 1,在每次侦测到冲突之后就会被乘以 1.05,因此会给那些参与到最近冲突子句中的变量较高的分数. 为了防止溢出,如果某些变量的活动分数比 <span class="math inline">\(10^{100}\)</span>高, 那么所有的变量分数包括常量 <span class="math inline">\(inc\)</span>都乘以 <span class="math inline">\(10^{-100}\)</span>.有着最高分数的变量将被选定. 被选定的变量的值, 要么是 <spanclass="math inline">\(\rm FALSE\)</span> , 要么随机, 或者,将先前的赋值重新赋给该变量. MINISAT 的成功之处在于,并没有尝试猜测变量的正确赋值, 重要的是基于学习的本地搜索,而不是去猜测当前分支的正确性. 因为, 即使是在可满足公式中的大多数分支中,也不能推出一组使得公式可满足的赋值.</p><div class="note note-success">            <p>感兴趣的读者可以进一步学习 CDCL 算法相关的内容: <ahref="https://cse442-17f.github.io/Conflict-Driven-Clause-Learning/">CSE442-17f</a>,<ahref="https://users.aalto.fi/~tjunttil/2020-DP-AUT/notes-sat/cdcl.html">CS-E3220</a>.</p>          </div>]]></content>
    
    
    <categories>
      
      <category>判定过程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>CDCL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Alice</title>
    <link href="/2021/12/b1229a78479c/"/>
    <url>/2021/12/b1229a78479c/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>岂曰无衣，与子同袍。--《秦风 无衣》</p>          </div>]]></content>
    
    
    
    <tags>
      
      <tag>42</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
